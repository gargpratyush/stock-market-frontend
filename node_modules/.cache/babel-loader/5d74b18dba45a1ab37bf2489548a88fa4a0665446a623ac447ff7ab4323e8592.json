{"ast":null,"code":"import { memo as e, useMemo as r, useState as i, useCallback as n, createElement as t, Fragment as o, forwardRef as a, useRef as s, useEffect as l } from \"react\";\nimport { useTheme as u, lineCurvePropType as d, blendModePropType as c, motionPropTypes as f, defsPropTypes as p, curveFromProp as h, useValueFormatter as y, useMotionConfig as b, useAnimatedPath as g, getLabelGenerator as m, DotsItem as v, withContainer as x, useDimensions as R, CartesianMarkers as q, bindDefs as O, SvgWrapper as S, ResponsiveWrapper as C, getRelativeCursor as T, isCursorInRect as M } from \"@nivo/core\";\nimport { ordinalColorsPropType as w, useOrdinalColorScale as B, useInheritedColor as k } from \"@nivo/colors\";\nimport { axisPropType as W, Grid as G, Axes as L, renderGridLinesToCanvas as P, renderAxesToCanvas as j } from \"@nivo/axes\";\nimport { LegendPropShape as F, BoxLegendSvg as V, renderLegendToCanvas as E } from \"@nivo/legends\";\nimport { BasicTooltip as Y, TableTooltip as D, Chip as X, useTooltip as z, Crosshair as A } from \"@nivo/tooltip\";\nimport { line as H, area as I } from \"d3-shape\";\nimport { computeXYScalesForSeries as J } from \"@nivo/scales\";\nimport K from \"prop-types\";\nimport { jsx as N, jsxs as Q } from \"react/jsx-runtime\";\nimport { useSpring as U, animated as Z } from \"@react-spring/web\";\nimport { Mesh as $, useVoronoiMesh as _, renderVoronoiToCanvas as ee, renderVoronoiCellToCanvas as re } from \"@nivo/voronoi\";\nfunction ie() {\n  return ie = Object.assign || function (e) {\n    for (var r = 1; r < arguments.length; r++) {\n      var i = arguments[r];\n      for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n]);\n    }\n    return e;\n  }, ie.apply(this, arguments);\n}\nvar ne = function (e) {\n  var r = e.point;\n  return N(Y, {\n    id: Q(\"span\", {\n      children: [\"x: \", N(\"strong\", {\n        children: r.data.xFormatted\n      }), \", y:\", \" \", N(\"strong\", {\n        children: r.data.yFormatted\n      })]\n    }),\n    enableChip: !0,\n    color: r.serieColor\n  });\n};\nne.propTypes = {\n  point: K.object.isRequired\n};\nvar te = e(ne),\n  oe = function (e) {\n    var r = e.slice,\n      i = e.axis,\n      n = u(),\n      t = \"x\" === i ? \"y\" : \"x\";\n    return N(D, {\n      rows: r.points.map(function (e) {\n        return [N(X, {\n          color: e.serieColor,\n          style: n.tooltip.chip\n        }, \"chip\"), e.serieId, N(\"span\", {\n          style: n.tooltip.tableCellValue,\n          children: e.data[t + \"Formatted\"]\n        }, \"value\")];\n      })\n    });\n  };\noe.propTypes = {\n  slice: K.object.isRequired,\n  axis: K.oneOf([\"x\", \"y\"]).isRequired\n};\nvar ae = e(oe),\n  se = {\n    data: K.arrayOf(K.shape({\n      id: K.oneOfType([K.string, K.number]).isRequired,\n      data: K.arrayOf(K.shape({\n        x: K.oneOfType([K.number, K.string, K.instanceOf(Date)]),\n        y: K.oneOfType([K.number, K.string, K.instanceOf(Date)])\n      })).isRequired\n    })).isRequired,\n    xScale: K.object.isRequired,\n    xFormat: K.oneOfType([K.func, K.string]),\n    yScale: K.object.isRequired,\n    yFormat: K.oneOfType([K.func, K.string]),\n    layers: K.arrayOf(K.oneOfType([K.oneOf([\"grid\", \"markers\", \"axes\", \"areas\", \"crosshair\", \"lines\", \"slices\", \"points\", \"mesh\", \"legends\"]), K.func])).isRequired,\n    curve: d.isRequired,\n    axisTop: W,\n    axisRight: W,\n    axisBottom: W,\n    axisLeft: W,\n    enableGridX: K.bool.isRequired,\n    enableGridY: K.bool.isRequired,\n    gridXValues: K.oneOfType([K.number, K.arrayOf(K.oneOfType([K.number, K.string, K.instanceOf(Date)]))]),\n    gridYValues: K.oneOfType([K.number, K.arrayOf(K.oneOfType([K.number, K.string, K.instanceOf(Date)]))]),\n    enablePoints: K.bool.isRequired,\n    pointSymbol: K.func,\n    pointSize: K.number.isRequired,\n    pointColor: K.any.isRequired,\n    pointBorderWidth: K.number.isRequired,\n    pointBorderColor: K.any.isRequired,\n    enablePointLabel: K.bool.isRequired,\n    pointLabel: K.oneOfType([K.string, K.func]).isRequired,\n    markers: K.arrayOf(K.shape({\n      axis: K.oneOf([\"x\", \"y\"]).isRequired,\n      value: K.oneOfType([K.number, K.string, K.instanceOf(Date)]).isRequired,\n      style: K.object\n    })),\n    colors: w.isRequired,\n    enableArea: K.bool.isRequired,\n    areaOpacity: K.number.isRequired,\n    areaBlendMode: c.isRequired,\n    areaBaselineValue: K.oneOfType([K.number, K.string, K.instanceOf(Date)]).isRequired,\n    lineWidth: K.number.isRequired,\n    legends: K.arrayOf(K.shape(F)).isRequired,\n    isInteractive: K.bool.isRequired,\n    debugMesh: K.bool.isRequired,\n    tooltip: K.oneOfType([K.func, K.object]).isRequired,\n    enableSlices: K.oneOf([\"x\", \"y\", !1]).isRequired,\n    debugSlices: K.bool.isRequired,\n    sliceTooltip: K.oneOfType([K.func, K.object]).isRequired,\n    enableCrosshair: K.bool.isRequired,\n    crosshairType: K.string.isRequired\n  },\n  le = ie({}, se, {\n    enablePointLabel: K.bool.isRequired,\n    role: K.string.isRequired,\n    useMesh: K.bool.isRequired\n  }, f, p),\n  ue = ie({\n    pixelRatio: K.number.isRequired\n  }, se),\n  de = {\n    curve: \"linear\",\n    xScale: {\n      type: \"point\"\n    },\n    yScale: {\n      type: \"linear\",\n      min: 0,\n      max: \"auto\"\n    },\n    layers: [\"grid\", \"markers\", \"axes\", \"areas\", \"crosshair\", \"lines\", \"points\", \"slices\", \"mesh\", \"legends\"],\n    axisBottom: {},\n    axisLeft: {},\n    enableGridX: !0,\n    enableGridY: !0,\n    enablePoints: !0,\n    pointSize: 6,\n    pointColor: {\n      from: \"color\"\n    },\n    pointBorderWidth: 0,\n    pointBorderColor: {\n      theme: \"background\"\n    },\n    enablePointLabel: !1,\n    pointLabel: \"yFormatted\",\n    colors: {\n      scheme: \"nivo\"\n    },\n    enableArea: !1,\n    areaBaselineValue: 0,\n    areaOpacity: .2,\n    areaBlendMode: \"normal\",\n    lineWidth: 2,\n    legends: [],\n    isInteractive: !0,\n    tooltip: te,\n    enableSlices: !1,\n    debugSlices: !1,\n    sliceTooltip: ae,\n    debugMesh: !1,\n    enableCrosshair: !0,\n    crosshairType: \"bottom-left\"\n  },\n  ce = ie({}, de, {\n    enablePointLabel: !1,\n    useMesh: !1,\n    animate: !0,\n    motionConfig: \"gentle\",\n    defs: [],\n    fill: [],\n    role: \"img\"\n  }),\n  fe = ie({}, de, {\n    pixelRatio: \"undefined\" != typeof window && window.devicePixelRatio || 1\n  }),\n  pe = function (e) {\n    var i = e.curve;\n    return r(function () {\n      return H().defined(function (e) {\n        return null !== e.x && null !== e.y;\n      }).x(function (e) {\n        return e.x;\n      }).y(function (e) {\n        return e.y;\n      }).curve(h(i));\n    }, [i]);\n  },\n  he = function (e) {\n    var i = e.curve,\n      n = e.yScale,\n      t = e.areaBaselineValue;\n    return r(function () {\n      return I().defined(function (e) {\n        return null !== e.x && null !== e.y;\n      }).x(function (e) {\n        return e.x;\n      }).y1(function (e) {\n        return e.y;\n      }).curve(h(i)).y0(n(t));\n    }, [i, n, t]);\n  },\n  ye = function (e) {\n    var i = e.enableSlices,\n      n = e.points,\n      t = e.width,\n      o = e.height;\n    return r(function () {\n      if (!1 === i) return [];\n      if (\"x\" === i) {\n        var e = new Map();\n        return n.forEach(function (r) {\n          null !== r.data.x && null !== r.data.y && (e.has(r.x) ? e.get(r.x).push(r) : e.set(r.x, [r]));\n        }), Array.from(e.entries()).sort(function (e, r) {\n          return e[0] - r[0];\n        }).map(function (e, r, i) {\n          var n,\n            a = e[0],\n            s = e[1],\n            l = i[r - 1],\n            u = i[r + 1];\n          return {\n            id: a,\n            x0: n = l ? a - (a - l[0]) / 2 : a,\n            x: a,\n            y0: 0,\n            y: 0,\n            width: u ? a - n + (u[0] - a) / 2 : t - n,\n            height: o,\n            points: s.reverse()\n          };\n        });\n      }\n      if (\"y\" === i) {\n        var r = new Map();\n        return n.forEach(function (e) {\n          null !== e.data.x && null !== e.data.y && (r.has(e.y) ? r.get(e.y).push(e) : r.set(e.y, [e]));\n        }), Array.from(r.entries()).sort(function (e, r) {\n          return e[0] - r[0];\n        }).map(function (e, r, i) {\n          var n,\n            a,\n            s = e[0],\n            l = e[1],\n            u = i[r - 1],\n            d = i[r + 1];\n          return n = u ? s - (s - u[0]) / 2 : s, a = d ? s - n + (d[0] - s) / 2 : o - n, {\n            id: s,\n            x0: 0,\n            x: 0,\n            y0: n,\n            y: s,\n            width: t,\n            height: a,\n            points: l.reverse()\n          };\n        });\n      }\n    }, [i, n]);\n  },\n  be = function (e) {\n    var t = e.data,\n      o = e.xScale,\n      a = void 0 === o ? ce.xScale : o,\n      s = e.xFormat,\n      l = e.yScale,\n      d = void 0 === l ? ce.yScale : l,\n      c = e.yFormat,\n      f = e.width,\n      p = e.height,\n      h = e.colors,\n      b = void 0 === h ? ce.colors : h,\n      g = e.curve,\n      m = void 0 === g ? ce.curve : g,\n      v = e.areaBaselineValue,\n      x = void 0 === v ? ce.areaBaselineValue : v,\n      R = e.pointColor,\n      q = void 0 === R ? ce.pointColor : R,\n      O = e.pointBorderColor,\n      S = void 0 === O ? ce.pointBorderColor : O,\n      C = e.enableSlices,\n      T = void 0 === C ? ce.enableSlicesTooltip : C,\n      M = y(s),\n      w = y(c),\n      W = B(b, \"id\"),\n      G = u(),\n      L = k(q, G),\n      P = k(S, G),\n      j = i([]),\n      F = j[0],\n      V = j[1],\n      E = r(function () {\n        return J(t.filter(function (e) {\n          return -1 === F.indexOf(e.id);\n        }), a, d, f, p);\n      }, [t, F, a, d, f, p]),\n      Y = E.xScale,\n      D = E.yScale,\n      X = E.series,\n      z = r(function () {\n        var e = t.map(function (e) {\n            return {\n              id: e.id,\n              label: e.id,\n              color: W(e)\n            };\n          }),\n          r = e.map(function (e) {\n            return ie({}, X.find(function (r) {\n              return r.id === e.id;\n            }), {\n              color: e.color\n            });\n          }).filter(function (e) {\n            return Boolean(e.id);\n          });\n        return {\n          legendData: e.map(function (e) {\n            return ie({}, e, {\n              hidden: !r.find(function (r) {\n                return r.id === e.id;\n              })\n            });\n          }).reverse(),\n          series: r\n        };\n      }, [t, X, W]),\n      A = z.legendData,\n      H = z.series,\n      I = n(function (e) {\n        V(function (r) {\n          return r.indexOf(e) > -1 ? r.filter(function (r) {\n            return r !== e;\n          }) : [].concat(r, [e]);\n        });\n      }, []),\n      K = function (e) {\n        var i = e.series,\n          n = e.getPointColor,\n          t = e.getPointBorderColor,\n          o = e.formatX,\n          a = e.formatY;\n        return r(function () {\n          return i.reduce(function (e, r) {\n            return [].concat(e, r.data.filter(function (e) {\n              return null !== e.position.x && null !== e.position.y;\n            }).map(function (i, s) {\n              var l = {\n                id: r.id + \".\" + s,\n                index: e.length + s,\n                serieId: r.id,\n                serieColor: r.color,\n                x: i.position.x,\n                y: i.position.y\n              };\n              return l.color = n(r), l.borderColor = t(l), l.data = ie({}, i.data, {\n                xFormatted: o(i.data.x),\n                yFormatted: a(i.data.y)\n              }), l;\n            }));\n          }, []);\n        }, [i, n, t, o, a]);\n      }({\n        series: H,\n        getPointColor: L,\n        getPointBorderColor: P,\n        formatX: M,\n        formatY: w\n      }),\n      N = ye({\n        enableSlices: T,\n        points: K,\n        width: f,\n        height: p\n      });\n    return {\n      legendData: A,\n      toggleSerie: I,\n      lineGenerator: pe({\n        curve: m\n      }),\n      areaGenerator: he({\n        curve: m,\n        yScale: D,\n        areaBaselineValue: x\n      }),\n      getColor: W,\n      series: H,\n      xScale: Y,\n      yScale: D,\n      slices: N,\n      points: K\n    };\n  },\n  ge = function (e) {\n    var r = e.areaBlendMode,\n      i = e.areaOpacity,\n      n = e.color,\n      t = e.fill,\n      o = e.path,\n      a = b(),\n      s = a.animate,\n      l = a.config,\n      u = g(o),\n      d = U({\n        color: n,\n        config: l,\n        immediate: !s\n      });\n    return N(Z.path, {\n      d: u,\n      fill: t || d.color,\n      fillOpacity: i,\n      strokeWidth: 0,\n      style: {\n        mixBlendMode: r\n      }\n    });\n  };\nge.propTypes = {\n  areaBlendMode: c.isRequired,\n  areaOpacity: K.number.isRequired,\n  color: K.string,\n  fill: K.string,\n  path: K.string.isRequired\n};\nvar me = function (e) {\n  var r = e.areaGenerator,\n    i = e.areaOpacity,\n    n = e.areaBlendMode,\n    t = e.lines.slice(0).reverse();\n  return N(\"g\", {\n    children: t.map(function (e) {\n      return N(ge, ie({\n        path: r(e.data.map(function (e) {\n          return e.position;\n        }))\n      }, ie({\n        areaOpacity: i,\n        areaBlendMode: n\n      }, e)), e.id);\n    })\n  });\n};\nme.propTypes = {\n  areaGenerator: K.func.isRequired,\n  areaOpacity: K.number.isRequired,\n  areaBlendMode: c.isRequired,\n  lines: K.arrayOf(K.object).isRequired\n};\nvar ve = e(me),\n  xe = function (e) {\n    var i = e.lineGenerator,\n      n = e.points,\n      t = e.color,\n      o = e.thickness,\n      a = r(function () {\n        return i(n);\n      }, [i, n]),\n      s = g(a);\n    return N(Z.path, {\n      d: s,\n      fill: \"none\",\n      strokeWidth: o,\n      stroke: t\n    });\n  };\nxe.propTypes = {\n  points: K.arrayOf(K.shape({\n    x: K.oneOfType([K.string, K.number]),\n    y: K.oneOfType([K.string, K.number])\n  })),\n  lineGenerator: K.func.isRequired,\n  color: K.string.isRequired,\n  thickness: K.number.isRequired\n};\nvar Re = e(xe),\n  qe = function (e) {\n    var r = e.lines,\n      i = e.lineGenerator,\n      n = e.lineWidth;\n    return r.slice(0).reverse().map(function (e) {\n      var r = e.id,\n        t = e.data,\n        o = e.color;\n      return N(Re, {\n        id: r,\n        points: t.map(function (e) {\n          return e.position;\n        }),\n        lineGenerator: i,\n        color: o,\n        thickness: n\n      }, r);\n    });\n  };\nqe.propTypes = {\n  lines: K.arrayOf(K.shape({\n    id: K.oneOfType([K.string, K.number]).isRequired,\n    color: K.string.isRequired,\n    data: K.arrayOf(K.shape({\n      data: K.shape({\n        x: K.oneOfType([K.string, K.number, K.instanceOf(Date)]),\n        y: K.oneOfType([K.string, K.number, K.instanceOf(Date)])\n      }).isRequired,\n      position: K.shape({\n        x: K.number,\n        y: K.number\n      }).isRequired\n    })).isRequired\n  })).isRequired,\n  lineWidth: K.number.isRequired,\n  lineGenerator: K.func.isRequired\n};\nvar Oe = e(qe),\n  Se = function (e) {\n    var r = e.slice,\n      i = e.axis,\n      o = e.debug,\n      a = e.tooltip,\n      s = e.isCurrent,\n      l = e.setCurrent,\n      u = z(),\n      d = u.showTooltipFromEvent,\n      c = u.hideTooltip,\n      f = n(function (e) {\n        d(t(a, {\n          slice: r,\n          axis: i\n        }), e, \"right\"), l(r);\n      }, [d, a, r]),\n      p = n(function (e) {\n        d(t(a, {\n          slice: r,\n          axis: i\n        }), e, \"right\");\n      }, [d, a, r]),\n      h = n(function () {\n        c(), l(null);\n      }, [c]);\n    return N(\"rect\", {\n      x: r.x0,\n      y: r.y0,\n      width: r.width,\n      height: r.height,\n      stroke: \"red\",\n      strokeWidth: o ? 1 : 0,\n      strokeOpacity: .75,\n      fill: \"red\",\n      fillOpacity: s && o ? .35 : 0,\n      onMouseEnter: f,\n      onMouseMove: p,\n      onMouseLeave: h\n    });\n  };\nSe.propTypes = {\n  slice: K.object.isRequired,\n  axis: K.oneOf([\"x\", \"y\"]).isRequired,\n  debug: K.bool.isRequired,\n  height: K.number.isRequired,\n  tooltip: K.oneOfType([K.func, K.object]),\n  isCurrent: K.bool.isRequired,\n  setCurrent: K.func.isRequired\n};\nvar Ce = e(Se),\n  Te = function (e) {\n    var r = e.slices,\n      i = e.axis,\n      n = e.debug,\n      t = e.height,\n      o = e.tooltip,\n      a = e.current,\n      s = e.setCurrent;\n    return r.map(function (e) {\n      return N(Ce, {\n        slice: e,\n        axis: i,\n        debug: n,\n        height: t,\n        tooltip: o,\n        setCurrent: s,\n        isCurrent: null !== a && a.id === e.id\n      }, e.id);\n    });\n  };\nTe.propTypes = {\n  slices: K.arrayOf(K.shape({\n    id: K.oneOfType([K.number, K.string, K.instanceOf(Date)]).isRequired,\n    x: K.number.isRequired,\n    y: K.number.isRequired,\n    points: K.arrayOf(K.object).isRequired\n  })).isRequired,\n  axis: K.oneOf([\"x\", \"y\"]).isRequired,\n  debug: K.bool.isRequired,\n  height: K.number.isRequired,\n  tooltip: K.oneOfType([K.func, K.object]).isRequired,\n  current: K.object,\n  setCurrent: K.func.isRequired\n};\nvar Me = e(Te),\n  we = function (e) {\n    var r = e.points,\n      i = e.symbol,\n      n = e.size,\n      t = e.borderWidth,\n      o = e.enableLabel,\n      a = e.label,\n      s = e.labelYOffset,\n      l = u(),\n      d = m(a),\n      c = r.slice(0).reverse().map(function (e) {\n        return {\n          id: e.id,\n          x: e.x,\n          y: e.y,\n          datum: e.data,\n          fill: e.color,\n          stroke: e.borderColor,\n          label: o ? d(e.data) : null\n        };\n      });\n    return N(\"g\", {\n      children: c.map(function (e) {\n        return N(v, {\n          x: e.x,\n          y: e.y,\n          datum: e.datum,\n          symbol: i,\n          size: n,\n          color: e.fill,\n          borderWidth: t,\n          borderColor: e.stroke,\n          label: e.label,\n          labelYOffset: s,\n          theme: l\n        }, e.id);\n      })\n    });\n  };\nwe.propTypes = {\n  points: K.arrayOf(K.object),\n  symbol: K.func,\n  size: K.number.isRequired,\n  color: K.func.isRequired,\n  borderWidth: K.number.isRequired,\n  borderColor: K.func.isRequired,\n  enableLabel: K.bool.isRequired,\n  label: K.oneOfType([K.string, K.func]).isRequired,\n  labelYOffset: K.number\n};\nvar Be = e(we),\n  ke = function (e) {\n    var r = e.points,\n      i = e.width,\n      o = e.height,\n      a = e.margin,\n      s = e.setCurrent,\n      l = e.onMouseEnter,\n      u = e.onMouseMove,\n      d = e.onMouseLeave,\n      c = e.onClick,\n      f = e.tooltip,\n      p = e.debug,\n      h = z(),\n      y = h.showTooltipAt,\n      b = h.hideTooltip,\n      g = n(function (e, r) {\n        y(t(f, {\n          point: e\n        }), [e.x + a.left, e.y + a.top], \"top\"), s(e), l && l(e, r);\n      }, [s, y, f, l, a]),\n      m = n(function (e, r) {\n        y(t(f, {\n          point: e\n        }), [e.x + a.left, e.y + a.top], \"top\"), s(e), u && u(e, r);\n      }, [s, y, f, u]),\n      v = n(function (e, r) {\n        b(), s(null), d && d(e, r);\n      }, [b, s, d]),\n      x = n(function (e, r) {\n        c && c(e, r);\n      }, [c]);\n    return N($, {\n      nodes: r,\n      width: i,\n      height: o,\n      onMouseEnter: g,\n      onMouseMove: m,\n      onMouseLeave: v,\n      onClick: x,\n      debug: p\n    });\n  };\nke.propTypes = {\n  points: K.arrayOf(K.object).isRequired,\n  width: K.number.isRequired,\n  height: K.number.isRequired,\n  margin: K.object.isRequired,\n  setCurrent: K.func.isRequired,\n  onMouseEnter: K.func,\n  onMouseMove: K.func,\n  onMouseLeave: K.func,\n  onClick: K.func,\n  tooltip: K.oneOfType([K.func, K.object]).isRequired,\n  debug: K.bool.isRequired\n};\nvar We = e(ke),\n  Ge = function (e) {\n    var r = e.data,\n      n = e.xScale,\n      t = e.xFormat,\n      a = e.yScale,\n      s = e.yFormat,\n      l = e.layers,\n      d = e.curve,\n      c = e.areaBaselineValue,\n      f = e.colors,\n      p = e.margin,\n      h = e.width,\n      y = e.height,\n      b = e.axisTop,\n      g = e.axisRight,\n      m = e.axisBottom,\n      v = e.axisLeft,\n      x = e.enableGridX,\n      C = e.enableGridY,\n      T = e.gridXValues,\n      M = e.gridYValues,\n      w = e.lineWidth,\n      B = e.enableArea,\n      W = e.areaOpacity,\n      P = e.areaBlendMode,\n      j = e.enablePoints,\n      F = e.pointSymbol,\n      E = e.pointSize,\n      Y = e.pointColor,\n      D = e.pointBorderWidth,\n      X = e.pointBorderColor,\n      z = e.enablePointLabel,\n      H = e.pointLabel,\n      I = e.pointLabelYOffset,\n      J = e.defs,\n      K = e.fill,\n      Q = e.markers,\n      U = e.legends,\n      Z = e.isInteractive,\n      $ = e.useMesh,\n      _ = e.debugMesh,\n      ee = e.onMouseEnter,\n      re = e.onMouseMove,\n      ne = e.onMouseLeave,\n      te = e.onClick,\n      oe = e.tooltip,\n      ae = e.enableSlices,\n      se = e.debugSlices,\n      le = e.sliceTooltip,\n      ue = e.enableCrosshair,\n      de = e.crosshairType,\n      ce = e.role,\n      fe = R(h, y, p),\n      pe = fe.margin,\n      he = fe.innerWidth,\n      ye = fe.innerHeight,\n      ge = fe.outerWidth,\n      me = fe.outerHeight,\n      xe = be({\n        data: r,\n        xScale: n,\n        xFormat: t,\n        yScale: a,\n        yFormat: s,\n        width: he,\n        height: ye,\n        colors: f,\n        curve: d,\n        areaBaselineValue: c,\n        pointColor: Y,\n        pointBorderColor: X,\n        enableSlices: ae\n      }),\n      Re = xe.legendData,\n      qe = xe.toggleSerie,\n      Se = xe.lineGenerator,\n      Ce = xe.areaGenerator,\n      Te = xe.series,\n      we = xe.xScale,\n      ke = xe.yScale,\n      Ge = xe.slices,\n      Le = xe.points,\n      Pe = u(),\n      je = k(Y, Pe),\n      Fe = k(X, Pe),\n      Ve = i(null),\n      Ee = Ve[0],\n      Ye = Ve[1],\n      De = i(null),\n      Xe = De[0],\n      ze = De[1],\n      Ae = {\n        grid: N(G, {\n          theme: Pe,\n          width: he,\n          height: ye,\n          xScale: x ? we : null,\n          yScale: C ? ke : null,\n          xValues: T,\n          yValues: M\n        }, \"grid\"),\n        markers: N(q, {\n          markers: Q,\n          width: he,\n          height: ye,\n          xScale: we,\n          yScale: ke,\n          theme: Pe\n        }, \"markers\"),\n        axes: N(L, {\n          xScale: we,\n          yScale: ke,\n          width: he,\n          height: ye,\n          theme: Pe,\n          top: b,\n          right: g,\n          bottom: m,\n          left: v\n        }, \"axes\"),\n        areas: null,\n        lines: N(Oe, {\n          lines: Te,\n          lineGenerator: Se,\n          lineWidth: w\n        }, \"lines\"),\n        slices: null,\n        points: null,\n        crosshair: null,\n        mesh: null,\n        legends: U.map(function (e, r) {\n          return N(V, ie({}, e, {\n            containerWidth: he,\n            containerHeight: ye,\n            data: e.data || Re,\n            theme: Pe,\n            toggleSerie: e.toggleSerie ? qe : void 0\n          }), \"legend.\" + r);\n        })\n      },\n      He = O(J, Te, K);\n    return B && (Ae.areas = N(ve, {\n      areaGenerator: Ce,\n      areaOpacity: W,\n      areaBlendMode: P,\n      lines: Te\n    }, \"areas\")), Z && !1 !== ae && (Ae.slices = N(Me, {\n      slices: Ge,\n      axis: ae,\n      debug: se,\n      height: ye,\n      tooltip: le,\n      current: Xe,\n      setCurrent: ze\n    }, \"slices\")), j && (Ae.points = N(Be, {\n      points: Le,\n      symbol: F,\n      size: E,\n      color: je,\n      borderWidth: D,\n      borderColor: Fe,\n      enableLabel: z,\n      label: H,\n      labelYOffset: I\n    }, \"points\")), Z && ue && (null !== Ee && (Ae.crosshair = N(A, {\n      width: he,\n      height: ye,\n      x: Ee.x,\n      y: Ee.y,\n      type: de\n    }, \"crosshair\")), null !== Xe && (Ae.crosshair = N(A, {\n      width: he,\n      height: ye,\n      x: Xe.x,\n      y: Xe.y,\n      type: ae\n    }, \"crosshair\"))), Z && $ && !1 === ae && (Ae.mesh = N(We, {\n      points: Le,\n      width: he,\n      height: ye,\n      margin: pe,\n      current: Ee,\n      setCurrent: Ye,\n      onMouseEnter: ee,\n      onMouseMove: re,\n      onMouseLeave: ne,\n      onClick: te,\n      tooltip: oe,\n      debug: _\n    }, \"mesh\")), N(S, {\n      defs: He,\n      width: ge,\n      height: me,\n      margin: pe,\n      role: ce,\n      children: l.map(function (r, i) {\n        return \"function\" == typeof r ? N(o, {\n          children: r(ie({}, e, {\n            innerWidth: he,\n            innerHeight: ye,\n            series: Te,\n            slices: Ge,\n            points: Le,\n            xScale: we,\n            yScale: ke,\n            lineGenerator: Se,\n            areaGenerator: Ce,\n            currentPoint: Ee,\n            setCurrentPoint: Ye,\n            currentSlice: Xe,\n            setCurrentSlice: ze\n          }))\n        }, i) : Ae[r];\n      })\n    });\n  };\nGe.propTypes = le, Ge.defaultProps = ce;\nvar Le = x(Ge),\n  Pe = function (e) {\n    return N(C, {\n      children: function (r) {\n        var i = r.width,\n          n = r.height;\n        return N(Le, ie({\n          width: i,\n          height: n\n        }, e));\n      }\n    });\n  },\n  je = function (e) {\n    var r = e.width,\n      o = e.height,\n      a = e.margin,\n      d = e.pixelRatio,\n      c = e.data,\n      f = e.xScale,\n      p = e.xFormat,\n      h = e.yScale,\n      y = e.yFormat,\n      b = e.curve,\n      g = e.layers,\n      m = e.colors,\n      v = e.lineWidth,\n      x = e.enableArea,\n      q = e.areaBaselineValue,\n      O = e.areaOpacity,\n      S = e.enablePoints,\n      C = e.pointSize,\n      w = e.pointColor,\n      B = e.pointBorderWidth,\n      k = e.pointBorderColor,\n      W = e.enableGridX,\n      G = e.gridXValues,\n      L = e.enableGridY,\n      F = e.gridYValues,\n      V = e.axisTop,\n      Y = e.axisRight,\n      D = e.axisBottom,\n      X = e.axisLeft,\n      A = e.legends,\n      H = e.isInteractive,\n      I = e.debugMesh,\n      J = e.onMouseLeave,\n      K = e.onClick,\n      Q = e.tooltip,\n      U = e.canvasRef,\n      Z = s(null),\n      $ = R(r, o, a),\n      ne = $.margin,\n      te = $.innerWidth,\n      oe = $.innerHeight,\n      ae = $.outerWidth,\n      se = $.outerHeight,\n      le = u(),\n      ue = i(null),\n      de = ue[0],\n      ce = ue[1],\n      fe = be({\n        data: c,\n        xScale: f,\n        xFormat: p,\n        yScale: h,\n        yFormat: y,\n        width: te,\n        height: oe,\n        colors: m,\n        curve: b,\n        areaBaselineValue: q,\n        pointColor: w,\n        pointBorderColor: k\n      }),\n      pe = fe.lineGenerator,\n      he = fe.areaGenerator,\n      ye = fe.series,\n      ge = fe.xScale,\n      me = fe.yScale,\n      ve = fe.points,\n      xe = _({\n        points: ve,\n        width: te,\n        height: oe,\n        debug: I\n      }),\n      Re = xe.delaunay,\n      qe = xe.voronoi;\n    l(function () {\n      U && (U.current = Z.current), Z.current.width = ae * d, Z.current.height = se * d;\n      var e = Z.current.getContext(\"2d\");\n      e.scale(d, d), e.fillStyle = le.background, e.fillRect(0, 0, ae, se), e.translate(ne.left, ne.top), g.forEach(function (r) {\n        if (\"function\" == typeof r && r({\n          ctx: e,\n          innerWidth: te,\n          innerHeight: oe,\n          series: ye,\n          points: ve,\n          xScale: ge,\n          yScale: me,\n          lineWidth: v,\n          lineGenerator: pe,\n          areaGenerator: he,\n          currentPoint: de,\n          setCurrentPoint: ce\n        }), \"grid\" === r && le.grid.line.strokeWidth > 0 && (e.lineWidth = le.grid.line.strokeWidth, e.strokeStyle = le.grid.line.stroke, W && P(e, {\n          width: te,\n          height: oe,\n          scale: ge,\n          axis: \"x\",\n          values: G\n        }), L && P(e, {\n          width: te,\n          height: oe,\n          scale: me,\n          axis: \"y\",\n          values: F\n        })), \"axes\" === r && j(e, {\n          xScale: ge,\n          yScale: me,\n          width: te,\n          height: oe,\n          top: V,\n          right: Y,\n          bottom: D,\n          left: X,\n          theme: le\n        }), \"areas\" === r && !0 === x && (e.save(), e.globalAlpha = O, he.context(e), ye.forEach(function (r) {\n          e.fillStyle = r.color, e.beginPath(), he(r.data.map(function (e) {\n            return e.position;\n          })), e.fill();\n        }), e.restore()), \"lines\" === r && (pe.context(e), ye.forEach(function (r) {\n          e.strokeStyle = r.color, e.lineWidth = v, e.beginPath(), pe(r.data.map(function (e) {\n            return e.position;\n          })), e.stroke();\n        })), \"points\" === r && !0 === S && C > 0 && ve.forEach(function (r) {\n          e.fillStyle = r.color, e.beginPath(), e.arc(r.x, r.y, C / 2, 0, 2 * Math.PI), e.fill(), B > 0 && (e.strokeStyle = r.borderColor, e.lineWidth = B, e.stroke());\n        }), \"mesh\" === r && !0 === I && (ee(e, qe), de && re(e, qe, de.index)), \"legends\" === r) {\n          var i = ye.map(function (e) {\n            return {\n              id: e.id,\n              label: e.id,\n              color: e.color\n            };\n          }).reverse();\n          A.forEach(function (r) {\n            E(e, ie({}, r, {\n              data: r.data || i,\n              containerWidth: te,\n              containerHeight: oe,\n              theme: le\n            }));\n          });\n        }\n      });\n    }, [Z, ae, se, g, le, pe, ye, ge, me, W, G, L, F, V, Y, D, X, A, ve, S, C, de]);\n    var Oe = n(function (e) {\n        var r = T(Z.current, e),\n          i = r[0],\n          n = r[1];\n        if (!M(ne.left, ne.top, te, oe, i, n)) return null;\n        var t = Re.find(i - ne.left, n - ne.top);\n        return ve[t];\n      }, [Z, ne, te, oe, Re]),\n      Se = z(),\n      Ce = Se.showTooltipFromEvent,\n      Te = Se.hideTooltip,\n      Me = n(function (e) {\n        var r = Oe(e);\n        ce(r), r ? Ce(t(Q, {\n          point: r\n        }), e) : Te();\n      }, [Oe, ce, Ce, Te, Q]),\n      we = n(function (e) {\n        Te(), ce(null), de && J && J(de, e);\n      }, [Te, ce, J]),\n      Be = n(function (e) {\n        if (K) {\n          var r = Oe(e);\n          r && K(r, e);\n        }\n      }, [Oe, K]);\n    return N(\"canvas\", {\n      ref: Z,\n      width: ae * d,\n      height: se * d,\n      style: {\n        width: ae,\n        height: se,\n        cursor: H ? \"auto\" : \"normal\"\n      },\n      onMouseEnter: H ? Me : void 0,\n      onMouseMove: H ? Me : void 0,\n      onMouseLeave: H ? we : void 0,\n      onClick: H ? Be : void 0\n    });\n  };\nje.propTypes = ue, je.defaultProps = fe;\nvar Fe = x(je),\n  Ve = a(function (e, r) {\n    return N(Fe, ie({}, e, {\n      canvasRef: r\n    }));\n  }),\n  Ee = a(function (e, r) {\n    return N(C, {\n      children: function (i) {\n        var n = i.width,\n          t = i.height;\n        return N(Ve, ie({\n          width: n,\n          height: t\n        }, e, {\n          ref: r\n        }));\n      }\n    });\n  });\nexport { Le as Line, Ve as LineCanvas, fe as LineCanvasDefaultProps, ue as LineCanvasPropTypes, ce as LineDefaultProps, le as LinePropTypes, Pe as ResponsiveLine, Ee as ResponsiveLineCanvas, he as useAreaGenerator, be as useLine, pe as useLineGenerator, ye as useSlices };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;AAYA,IAAMA,KAAmB;EAAA,IAAGC;EAAAA,OAEpBC,EAACC;IACGC,IACIC;MAAAA,kBACOH;QAAAA,UAASD,EAAMK,KAAKC;MAAAA,YAAyB,KAChDL;QAAAA,UAASD,EAAMK,KAAKE;MAAAA;IAAAA;IAG5BC,aAAY;IACZC,OAAOT,EAAMU;EAAAA;AAAAA;AAKzBX,GAAiBY,YAAY;EACzBX,OAAOY,EAAUC,OAAOC;AAAAA;AAG5B,SAAeC,EAAKhB;EClBdiB,KAAe;IAAA,IAAGC;MAAOC;MACrBC,IAAQC;MACRC,IAAqB,QAATH,IAAe,MAAM;IAAA,OAGnCjB,EAACqB;MACGC,MAAMN,EAAMO,OAAOC,IAAI;QAAAzB,OAAS,CAC5BC,EAACyB;UAAgBjB,OAAOT,EAAMU;UAAYiB,OAAOR,EAAMS,QAAQC;QAAAA,GAArD,SACV7B,EAAM8B,SACN7B;UAAkB0B,OAAOR,EAAMS,QAAQG;UAAAA,UAClC/B,EAAMK,KAAQgB;QAAAA,GADT;MAAA;IAAA;EAAA;AAQ1BL,GAAaL,YAAY;EACrBM,OAAOL,EAAUC,OAAOC;EACxBI,MAAMN,EAAUoB,MAAM,CAAC,KAAK,MAAMlB;AAAAA;AAGtC,SAAeC,EAAKC;ECnBdiB,KAAkB;IACpB5B,MAAMO,EAAUsB,QACZtB,EAAUuB,MAAM;MACZhC,IAAIS,EAAUwB,UAAU,CAACxB,EAAUyB,QAAQzB,EAAU0B,SAASxB;MAC9DT,MAAMO,EAAUsB,QACZtB,EAAUuB,MAAM;QACZI,GAAG3B,EAAUwB,UAAU,CACnBxB,EAAU0B,QACV1B,EAAUyB,QACVzB,EAAU4B,WAAWC;QAEzBC,GAAG9B,EAAUwB,UAAU,CACnBxB,EAAU0B,QACV1B,EAAUyB,QACVzB,EAAU4B,WAAWC;MAAAA,IAG/B3B;IAAAA,IAERA;IAEF6B,QAAQ/B,EAAUC,OAAOC;IACzB8B,SAAShC,EAAUwB,UAAU,CAACxB,EAAUiC,MAAMjC,EAAUyB;IACxDS,QAAQlC,EAAUC,OAAOC;IACzBiC,SAASnC,EAAUwB,UAAU,CAACxB,EAAUiC,MAAMjC,EAAUyB;IAExDW,QAAQpC,EAAUsB,QACdtB,EAAUwB,UAAU,CAChBxB,EAAUoB,MAAM,CACZ,QACA,WACA,QACA,SACA,aACA,SACA,UACA,UACA,QACA,aAEJpB,EAAUiC,QAEhB/B;IAEFmC,OAAOC,EAAkBpC;IAEzBqC,SAASC;IACTC,WAAWD;IACXE,YAAYF;IACZG,UAAUH;IAEVI,aAAa5C,EAAU6C,KAAK3C;IAC5B4C,aAAa9C,EAAU6C,KAAK3C;IAC5B6C,aAAa/C,EAAUwB,UAAU,CAC7BxB,EAAU0B,QACV1B,EAAUsB,QACNtB,EAAUwB,UAAU,CAACxB,EAAU0B,QAAQ1B,EAAUyB,QAAQzB,EAAU4B,WAAWC;IAGtFmB,aAAahD,EAAUwB,UAAU,CAC7BxB,EAAU0B,QACV1B,EAAUsB,QACNtB,EAAUwB,UAAU,CAACxB,EAAU0B,QAAQ1B,EAAUyB,QAAQzB,EAAU4B,WAAWC;IAItFoB,cAAcjD,EAAU6C,KAAK3C;IAC7BgD,aAAalD,EAAUiC;IACvBkB,WAAWnD,EAAU0B,OAAOxB;IAC5BkD,YAAYpD,EAAUqD,IAAInD;IAC1BoD,kBAAkBtD,EAAU0B,OAAOxB;IACnCqD,kBAAkBvD,EAAUqD,IAAInD;IAChCsD,kBAAkBxD,EAAU6C,KAAK3C;IACjCuD,YAAYzD,EAAUwB,UAAU,CAACxB,EAAUyB,QAAQzB,EAAUiC,OAAO/B;IAEpEwD,SAAS1D,EAAUsB,QACftB,EAAUuB,MAAM;MACZjB,MAAMN,EAAUoB,MAAM,CAAC,KAAK,MAAMlB;MAClCyD,OAAO3D,EAAUwB,UAAU,CACvBxB,EAAU0B,QACV1B,EAAUyB,QACVzB,EAAU4B,WAAWC,QACtB3B;MACHa,OAAOf,EAAUC;IAAAA;IAIzB2D,QAAQC,EAAsB3D;IAE9B4D,YAAY9D,EAAU6C,KAAK3C;IAC3B6D,aAAa/D,EAAU0B,OAAOxB;IAC9B8D,eAAeC,EAAkB/D;IACjCgE,mBAAmBlE,EAAUwB,UAAU,CACnCxB,EAAU0B,QACV1B,EAAUyB,QACVzB,EAAU4B,WAAWC,QACtB3B;IACHiE,WAAWnE,EAAU0B,OAAOxB;IAE5BkE,SAASpE,EAAUsB,QAAQtB,EAAUuB,MAAM8C,IAAkBnE;IAE7DoE,eAAetE,EAAU6C,KAAK3C;IAC9BqE,WAAWvE,EAAU6C,KAAK3C;IAE1Bc,SAAShB,EAAUwB,UAAU,CAACxB,EAAUiC,MAAMjC,EAAUC,SAASC;IAEjEsE,cAAcxE,EAAUoB,MAAM,CAAC,KAAK,MAAK,IAAQlB;IACjDuE,aAAazE,EAAU6C,KAAK3C;IAC5BwE,cAAc1E,EAAUwB,UAAU,CAACxB,EAAUiC,MAAMjC,EAAUC,SAASC;IAEtEyE,iBAAiB3E,EAAU6C,KAAK3C;IAChC0E,eAAe5E,EAAUyB,OAAOvB;EAAAA;EAGvB2E,YACNxD;IACHmC,kBAAkBxD,EAAU6C,KAAK3C;IACjC4E,MAAM9E,EAAUyB,OAAOvB;IACvB6E,SAAS/E,EAAU6C,KAAK3C;EAAAA,GACrB8E,GACAC;EAGMC;IACTC,YAAYnF,EAAU0B,OAAOxB;EAAAA,GAC1BmB;EAGD+D,KAAqB;IACvB/C,OAAO;IAEPN,QAAQ;MACJsD,MAAM;IAAA;IAEVnD,QAAQ;MACJmD,MAAM;MACNC,KAAK;MACLC,KAAK;IAAA;IAGTnD,QAAQ,CACJ,QACA,WACA,QACA,SACA,aACA,SACA,UACA,UACA,QACA;IAEJM,YAAY;IACZC,UAAU;IACVC,cAAa;IACbE,cAAa;IAEbG,eAAc;IACdE,WAAW;IACXC,YAAY;MAAEoC,MAAM;IAAA;IACpBlC,kBAAkB;IAClBC,kBAAkB;MAAEhD,OAAO;IAAA;IAC3BiD,mBAAkB;IAClBC,YAAY;IAEZG,QAAQ;MAAE6B,QAAQ;IAAA;IAClB3B,aAAY;IACZI,mBAAmB;IACnBH,aAAa;IACbC,eAAe;IACfG,WAAW;IAEXC,SAAS;IAETE,gBAAe;IACftD,SAAS0E;IACTlB,eAAc;IACdC,cAAa;IACbC,cAActE;IACdmE,YAAW;IACXI,kBAAiB;IACjBC,eAAe;EAAA;EAGNe,YACNP;IACH5B,mBAAkB;IAClBuB,UAAS;IACTa,UAAS;IACTC,cAAc;IACdC,MAAM;IACNC,MAAM;IACNjB,MAAM;EAAA;EAGGkB,YACNZ;IACHD,YAA8B,sBAAXc,UAAyBA,OAAOC,oBAAwB;EAAA;ECtMlEC,KAAmB;IAAA,IAAG9D;IAAAA,OACxB+D,EACH;MAAA,OACIC,IACKC,QAAQ;QAAAC,OAAa,SAARA,EAAE5E,KAAsB,SAAR4E,EAAEzE;MAAAA,GAC/BH,EAAE;QAAA4E,OAAKA,EAAE5E;MAAAA,GACTG,EAAE;QAAAyE,OAAKA,EAAEzE;MAAAA,GACTO,MAAMmE,EAAcnE;IAAAA,GAC7B,CAACA;EAAAA;EAIIoE,KAAmB;IAAA,IAAGpE;MAAOH;MAAQgC;IAAAA,OACvCkC,EAAQ;MAAA,OACJM,IACFJ,QAAQ;QAAAC,OAAa,SAARA,EAAE5E,KAAsB,SAAR4E,EAAEzE;MAAAA,GAC/BH,EAAE;QAAA4E,OAAKA,EAAE5E;MAAAA,GACTgF,GAAG;QAAAJ,OAAKA,EAAEzE;MAAAA,GACVO,MAAMmE,EAAcnE,IACpBuE,GAAG1E,EAAOgC;IAAAA,GAChB,CAAC7B,GAAOH,GAAQgC;EAAAA;EAkCV2C,KAAY;IAAA,IAAGrC;MAAc5D;MAAQkG;MAAOC;IAAAA,OAC9CX,EAAQ;MAAA,KACU,MAAjB5B,GAAwB,OAAO;MAAA,IAEd,QAAjBA,GAAsB;QAAA,IAChB3D,IAAM,IAAImG;QAAAA,OAChBpG,EAAOqG,QAAQ;UACU,SAAjB7H,EAAMK,KAAKkC,KAA+B,SAAjBvC,EAAMK,KAAKqC,MACnCjB,EAAIqG,IAAI9H,EAAMuC,KACdd,EAAIsG,IAAI/H,EAAMuC,GAAGyF,KAAKhI,KADJyB,EAAIwG,IAAIjI,EAAMuC,GAAG,CAACvC;QAAAA,IAGtCkI,MAAM9B,KAAK3E,EAAI0G,WACjBC,KAAK,UAACC,GAAGC;UAAAA,OAAMD,EAAE,KAAKC,EAAE;QAAA,GACxB7G,IAAI,aAAmB8G,GAAGC;UAAAA,IAInBC;YAJDlG;YAAGmG;YACAC,IAAYH,EAAOD,IAAI;YACvBK,IAAYJ,EAAOD,IAAI;UAAA,OAUtB;YACHpI,IAAIoC;YACJkG,IARCA,IADAE,IACKpG,KAAKA,IAAIoG,EAAU,MAAM,IADdpG;YAUjBA;YACAiF,IAAI;YACJ9E,GAAG;YACHgF,OATCkB,IACarG,IAAIkG,KAAMG,EAAU,KAAKrG,KAAK,IADnBmF,IAAQe;YAUjCd;YACAnG,QAAQkH,EAAYG;UAAAA;QAAAA;MAAAA;MAG7B,IAAqB,QAAjBzD,GAAsB;QAAA,IACvB3D,IAAM,IAAImG;QAAAA,OAChBpG,EAAOqG,QAAQ;UACU,SAAjB7H,EAAMK,KAAKkC,KAA+B,SAAjBvC,EAAMK,KAAKqC,MACnCjB,EAAIqG,IAAI9H,EAAM0C,KACdjB,EAAIsG,IAAI/H,EAAM0C,GAAGsF,KAAKhI,KADJyB,EAAIwG,IAAIjI,EAAM0C,GAAG,CAAC1C;QAAAA,IAGtCkI,MAAM9B,KAAK3E,EAAI0G,WACjBC,KAAK,UAACC,GAAGC;UAAAA,OAAMD,EAAE,KAAKC,EAAE;QAAA,GACxB7G,IAAI,aAAmB8G,GAAGC;UAAAA,IAInBhB;YAIAsB;YARDpG;YAAGgG;YACAC,IAAYH,EAAOD,IAAI;YACvBK,IAAYJ,EAAOD,IAAI;UAAA,OAIxBf,IADAmB,IACKjG,KAAKA,IAAIiG,EAAU,MAAM,IADdjG,GAKhBoG,IADAF,IACclG,IAAI8E,KAAMoB,EAAU,KAAKlG,KAAK,IADnBiF,IAASH,GAGhC;YACHrH,IAAIuC;YACJ+F,IAAI;YACJlG,GAAG;YACHiF;YACA9E;YACAgF;YACAC,QAAQmB;YACRtH,QAAQkH,EAAYG;UAAAA;QAAAA;MAAAA;IAAAA,GAIrC,CAACzD,GAAc5D;EAAAA;EAGTuH,KAAU;IAAA,IACnB1I;MAAAA,MACAsC;MAAQqG,mBAAazC,GAAiB5D;MACtCC;MAAAA,MACAE;MAAQmG,mBAAa1C,GAAiBzD;MACtCC;MACA2E;MACAC;MAAAA,MACAnD;MAAAA,mBAAS+B,GAAiB/B;MAAAA,MAC1BvB;MAAAA,mBAAQsD,GAAiBtD;MAAAA,MACzB6B;MAAAA,mBAAoByB,GAAiBzB;MAAAA,MACrCd;MAAAA,mBAAauC,GAAiBvC;MAAAA,MAC9BG;MAAAA,mBAAmBoC,GAAiBpC;MAAAA,MACpCiB;MAAAA,mBAAemB,GAAiB2C;MAE1BC,IAAUC,EAAkBxG;MAC5ByG,IAAUD,EAAkBrG;MAC5BuG,IAAWC,EAAqB/E,GAAQ;MACxCrD,IAAQC;MACRoI,IAAgBC,EAAkBzF,GAAY7C;MAC9CuI,IAAsBD,EAAkBtF,GAAkBhD;MAAAA,IAC9BwI,EAAS;MAApCC;MAAWC;MAAAA,IAMd7C,EACA;QAAA,OACI8C,EACIzJ,EAAK0J,OAAO;UAAAC,QAAwC,MAAhCJ,EAAUK,QAAQD,EAAK7J;QAAAA,IAC3C6I,GACAC,GACAvB,GACAC;MAAAA,GAER,CAACtH,GAAMuJ,GAAWZ,GAAYC,GAAYvB,GAAOC;MAZjDhF;MACAG;MACQoH,MAARC;MAAAA,IAa2BnD,EAAQ;QAAA,IAC7BoD,IAAgB/J,EAAKoB,IAAI;YAAAwF,OAAS;cACpC9G,IAAI8G,EAAK9G;cACTkK,OAAOpD,EAAK9G;cACZM,OAAO6I,EAASrC;YAAAA;UAAAA;UAEdkD,IAASC,EACV3I,IAAI;YAAA6I,cACEJ,EAAUK,KAAK;cAAAC,OAASA,EAAMrK,OAAOmK,EAAMnK;YAAAA;cAC9CM,OAAO6J,EAAM7J;YAAAA;UAAAA,GAEhBsJ,OAAO;YAAAC,OAAQS,QAAQT,EAAK7J;UAAAA;QAAAA,OAK1B;UAAEuK,YAJUN,EACd3I,IAAI;YAAAuI,cAAcA;cAAMW,SAASR,EAAOI,KAAK;gBAAAC,OAASA,EAAMrK,OAAO6J,EAAK7J;cAAAA;YAAAA;UAAAA,GACxE0I;UAEgBsB;QAAAA;MAAAA,GACtB,CAAC9J,GAAM6J,GAAWZ;MAjBboB;MAAYP;MAmBdS,IAAcC,EAAY;QAC5BhB,EAAa;UAAAiB,OACTA,EAAMb,QAAQ9J,MAAO,IAAI2K,EAAMf,OAAO;YAAAC,OAAQA,MAAS7J;UAAAA,eAAU2K,IAAO3K;QAAAA;MAAAA,GAE7E;MAEGqB,IAvKQ;QAAA,IAAG2I;UAAQX;UAAeE;UAAqBP;UAASE;QAAAA,OAC/DrC,EAAQ;UAAA,OACJmD,EAAOY,OAAO,UAACC,GAAKR;YAAAA,iBAEhBQ,GACAR,EAAMnK,KACJ0J,OAAO;cAAAO,OAA8B,SAArBA,EAAMW,SAAS1I,KAAmC,SAArB+H,EAAMW,SAASvI;YAAAA,GAC5DjB,IAAI,UAAC6I,GAAO/B;cAAAA,IACHvI,IAAQ;gBACVG,IAAOqK,EAAMrK,WAAMoI;gBACnB2C,OAAOF,EAAIG,SAAS5C;gBACpBzG,SAAS0I,EAAMrK;gBACfO,YAAY8J,EAAM/J;gBAClB8B,GAAG+H,EAAMW,SAAS1I;gBAClBG,GAAG4H,EAAMW,SAASvI;cAAAA;cAAAA,OAEtB1C,EAAMS,QAAQ+I,EAAcgB,IAC5BxK,EAAMoL,cAAc1B,EAAoB1J,IACxCA,EAAMK,cACCiK,EAAMjK;gBACTC,YAAY6I,EAAQmB,EAAMjK,KAAKkC;gBAC/BhC,YAAY8I,EAAQiB,EAAMjK,KAAKqC;cAAAA,IAG5B1C;YAAAA;UAAAA,GAGpB;QAAA,GACJ,CAACmK,GAAQX,GAAeE,GAAqBP,GAASE;MAAAA,CA2I1CgC,CAAU;QACrBlB;QACAX;QACAE;QACAP;QACAE;MAAAA;MAGEb,IAASf,GAAU;QACrBrC;QACA5D;QACAkG;QACAC;MAAAA;IAAAA,OAUG;MACH+C;MACAE;MACAU,eAVkBvE,GAAiB;QAAE9D;MAAAA;MAWrCsI,eAVkBlE,GAAiB;QACnCpE;QACAH;QACAgC;MAAAA;MAQAwE;MACAa;MACAxH;MACAG;MACA0F;MACAhH;IAAAA;EAAAA;EChOFgK,KAAW;IAAA,IAAG5G;MAAeD;MAAalE;MAAOkG;MAAM8E;MAAAA,IACfC;MAAlClF;MAAiBmF,MAARC;MAEXC,IAAeC,EAAgBL;MAC/BM,IAAgBC,EAAU;QAC5BvL;QACAmL,QAAQD;QACRM,YAAYzF;MAAAA;IAAAA,OAIZvG,EAACiM,EAAST;MACNtE,GAAG0E;MACHlF,MAAMA,KAAcoF,EAActL;MAClC0L,aAAaxH;MACbyH,aAAa;MACbzK,OAAO;QACH0K,cAAczH;MAAAA;IAAAA;EAAAA;AAM9B4G,GAAS7K,YAAY;EACjBiE,eAAeC,EAAkB/D;EACjC6D,aAAa/D,EAAU0B,OAAOxB;EAC9BL,OAAOG,EAAUyB;EACjBsE,MAAM/F,EAAUyB;EAChBoJ,MAAM7K,EAAUyB,OAAOvB;AAAAA;AAG3B,IAAMwL,KAAQ;EAAA,IAAGf;IAAe5G;IAAaC;IACnC2H,MADkDC,MAC5BvL,MAAM,GAAG4H;EAAAA,OAGjC5I;IAAAA,UACKsM,EAAc9K,IAAI;MAAAwF,OACfhH,EAACuL;QAEGC,MAAMF,EAActE,EAAK5G,KAAKoB,IAAI;UAAA0F,OAAKA,EAAE8D;QAAAA;MAAAA;QACnCtG;QAAaC;MAAAA,GAAkBqC,KAFhCA,EAAK9G;IAAAA;EAAAA;AAAAA;AAS9BmM,GAAM3L,YAAY;EACd4K,eAAe3K,EAAUiC,KAAK/B;EAC9B6D,aAAa/D,EAAU0B,OAAOxB;EAC9B8D,eAAeC,EAAkB/D;EACjC0L,OAAO5L,EAAUsB,QAAQtB,EAAUC,QAAQC;AAAAA;AAG/C,SAAeC,EAAKuL;ECtDdG,KAAY;IAAA,IAAGnB;MAAe9J;MAAQf;MAAOiM;MACzCjB,IAAOzE,EAAQ;QAAA,OAAMsE,EAAc9J;MAAAA,GAAS,CAAC8J,GAAe9J;MAC5DqK,IAAeC,EAAgBL;IAAAA,OAE9BxL,EAACiM,EAAST;MAAKtE,GAAG0E;MAAclF,MAAK;MAAOyF,aAAaM;MAAWC,QAAQlM;IAAAA;EAAAA;AAGvFgM,GAAU9L,YAAY;EAClBa,QAAQZ,EAAUsB,QACdtB,EAAUuB,MAAM;IACZI,GAAG3B,EAAUwB,UAAU,CAACxB,EAAUyB,QAAQzB,EAAU0B;IACpDI,GAAG9B,EAAUwB,UAAU,CAACxB,EAAUyB,QAAQzB,EAAU0B;EAAAA;EAG5DgJ,eAAe1K,EAAUiC,KAAK/B;EAC9BL,OAAOG,EAAUyB,OAAOvB;EACxB4L,WAAW9L,EAAU0B,OAAOxB;AAAAA;AAGhC,SAAeC,EAAK0L;ECpBdG,KAAQ;IAAA,IAAGJ;MAAOlB;MAAevG;IAAAA,OAC5ByH,EACFvL,MAAM,GACN4H,UACApH,IAAI;MAAA,IAAGtB;QAAIE;QAAMI;MAAAA,OACdR,EAACwM;QAEGtM,IAAIA;QACJqB,QAAQnB,EAAKoB,IAAI;UAAA0F,OAAKA,EAAE8D;QAAAA;QACxBK,eAAeA;QACf7K,OAAOA;QACPiM,WAAW3H;MAAAA,GALN5E;IAAAA;EAAAA;AAUrByM,GAAMjM,YAAY;EACd6L,OAAO5L,EAAUsB,QACbtB,EAAUuB,MAAM;IACZhC,IAAIS,EAAUwB,UAAU,CAACxB,EAAUyB,QAAQzB,EAAU0B,SAASxB;IAC9DL,OAAOG,EAAUyB,OAAOvB;IACxBT,MAAMO,EAAUsB,QACZtB,EAAUuB,MAAM;MACZ9B,MAAMO,EAAUuB,MAAM;QAClBI,GAAG3B,EAAUwB,UAAU,CACnBxB,EAAUyB,QACVzB,EAAU0B,QACV1B,EAAU4B,WAAWC;QAEzBC,GAAG9B,EAAUwB,UAAU,CACnBxB,EAAUyB,QACVzB,EAAU0B,QACV1B,EAAU4B,WAAWC;MAAAA,GAE1B3B;MACHmK,UAAUrK,EAAUuB,MAAM;QACtBI,GAAG3B,EAAU0B;QACbI,GAAG9B,EAAU0B;MAAAA,GACdxB;IAAAA,IAETA;EAAAA,IAERA;EACFiE,WAAWnE,EAAU0B,OAAOxB;EAC5BwK,eAAe1K,EAAUiC,KAAK/B;AAAAA;AAGlC,SAAeC,EAAK6L;EC/CdC,KAAa;IAAA,IAAG5L;MAAOC;MAAM4L;MAAOlL;MAASmL;MAAWC;MAAAA,IACZC;MAAtCC;MAAsBC;MAExBC,IAAmBvC,EACrB;QACIqC,EAAqBG,EAAczL,GAAS;UAAEX;UAAOC;QAAAA,IAASoM,GAAO,UACrEN,EAAW/L;MAAAA,GAEf,CAACiM,GAAsBtL,GAASX;MAG9BsM,IAAkB1C,EACpB;QACIqC,EAAqBG,EAAczL,GAAS;UAAEX;UAAOC;QAAAA,IAASoM,GAAO;MAAA,GAEzE,CAACJ,GAAsBtL,GAASX;MAG9BuM,IAAmB3C,EAAY;QACjCsC,KACAH,EAAW;MAAA,GACZ,CAACG;IAAAA,OAGAlN;MACIsC,GAAGtB,EAAMwH;MACT/F,GAAGzB,EAAMuG;MACTE,OAAOzG,EAAMyG;MACbC,QAAQ1G,EAAM0G;MACdgF,QAAO;MACPP,aAAaU,IAAQ,IAAI;MACzBW,eAAe;MACf9G,MAAK;MACLwF,aAAaY,KAAaD,IAAQ,MAAO;MACzCY,cAAcN;MACdO,aAAaJ;MACbK,cAAcJ;IAAAA;EAAAA;AAK1BX,GAAWlM,YAAY;EACnBM,OAAOL,EAAUC,OAAOC;EACxBI,MAAMN,EAAUoB,MAAM,CAAC,KAAK,MAAMlB;EAClCgM,OAAOlM,EAAU6C,KAAK3C;EACtB6G,QAAQ/G,EAAU0B,OAAOxB;EACzBc,SAAShB,EAAUwB,UAAU,CAACxB,EAAUiC,MAAMjC,EAAUC;EACxDkM,WAAWnM,EAAU6C,KAAK3C;EAC1BkM,YAAYpM,EAAUiC,KAAK/B;AAAAA;AAG/B,SAAeC,EAAK8L;ECnDdgB,KAAS;IAAA,IAAGrF;MAAQtH;MAAM4L;MAAOnF;MAAQ/F;MAASkM;MAASd;IAAAA,OACtDxE,EAAO/G,IAAI;MAAAR,OACdhB,EAAC4M;QAEG5L,OAAOA;QACPC,MAAMA;QACN4L,OAAOA;QACPnF,QAAQA;QACR/F,SAASA;QACToL,YAAYA;QACZD,WAAuB,SAAZe,KAAoBA,EAAQ3N,OAAOc,EAAMd;MAAAA,GAP/Cc,EAAMd;IAAAA;EAAAA;AAYvB0N,GAAOlN,YAAY;EACf6H,QAAQ5H,EAAUsB,QACdtB,EAAUuB,MAAM;IACZhC,IAAIS,EAAUwB,UAAU,CACpBxB,EAAU0B,QACV1B,EAAUyB,QACVzB,EAAU4B,WAAWC,QACtB3B;IACHyB,GAAG3B,EAAU0B,OAAOxB;IACpB4B,GAAG9B,EAAU0B,OAAOxB;IACpBU,QAAQZ,EAAUsB,QAAQtB,EAAUC,QAAQC;EAAAA,IAElDA;EACFI,MAAMN,EAAUoB,MAAM,CAAC,KAAK,MAAMlB;EAClCgM,OAAOlM,EAAU6C,KAAK3C;EACtB6G,QAAQ/G,EAAU0B,OAAOxB;EACzBc,SAAShB,EAAUwB,UAAU,CAACxB,EAAUiC,MAAMjC,EAAUC,SAASC;EACjEgN,SAASlN,EAAUC;EACnBmM,YAAYpM,EAAUiC,KAAK/B;AAAAA;AAG/B,SAAeC,EAAK8M;ECpCdE,KAAS;IAAA,IAAGvM;MAAQwM;MAAQC;MAAMC;MAAaC;MAAa9D;MAAO+D;MAC/DjN,IAAQC;MACRiN,IAAWC,EAAkBjE;MAM7BkE,IAAe/M,EAChBP,MAAM,GACN4H,UACApH,IAAI;QAAAzB,OACmB;UAChBG,IAAIH,EAAMG;UACVoC,GAAGvC,EAAMuC;UACTG,GAAG1C,EAAM0C;UACT4H,OAAOtK,EAAMK;UACbsG,MAAM3G,EAAMS;UACZkM,QAAQ3M,EAAMoL;UACdf,OAAO8D,IAAcE,EAASrO,EAAMK,QAAQ;QAAA;MAAA;IAAA,OAOpDJ;MAAAA,UACKsO,EAAa9M,IAAI;QAAAzB,OACdC,EAACuO;UAEGjM,GAAGvC,EAAMuC;UACTG,GAAG1C,EAAM0C;UACT4H,OAAOtK,EAAMsK;UACb0D,QAAQA;UACRC,MAAMA;UACNxN,OAAOT,EAAM2G;UACbuH,aAAaA;UACb9C,aAAapL,EAAM2M;UACnBtC,OAAOrK,EAAMqK;UACb+D,cAAcA;UACdjN,OAAOA;QAAAA,GAXFnB,EAAMG;MAAAA;IAAAA;EAAAA;AAkB/B4N,GAAOpN,YAAY;EACfa,QAAQZ,EAAUsB,QAAQtB,EAAUC;EACpCmN,QAAQpN,EAAUiC;EAClBoL,MAAMrN,EAAU0B,OAAOxB;EACvBL,OAAOG,EAAUiC,KAAK/B;EACtBoN,aAAatN,EAAU0B,OAAOxB;EAC9BsK,aAAaxK,EAAUiC,KAAK/B;EAC5BqN,aAAavN,EAAU6C,KAAK3C;EAC5BuJ,OAAOzJ,EAAUwB,UAAU,CAACxB,EAAUyB,QAAQzB,EAAUiC,OAAO/B;EAC/DsN,cAAcxN,EAAU0B;AAAAA;AAG5B,SAAevB,EAAKgN;EC1DdU,KAAO;IAAA,IACTjN;MACAkG;MACAC;MACA+G;MACA1B;MACAU;MACAC;MACAC;MACAe;MACA/M;MACAkL;MAAAA,IAEuCG;MAA/B2B;MAAezB;MAEjBC,IAAmBvC,EACrB,UAAC7K,GAAOsN;QACJsB,EACIvB,EAAczL,GAAS;UAAE5B;QAAAA,IACzB,CAACA,EAAMuC,IAAImM,EAAOG,MAAM7O,EAAM0C,IAAIgM,EAAOI,MACzC,QAEJ9B,EAAWhN,IACX0N,KAAgBA,EAAa1N,GAAOsN;MAAAA,GAExC,CAACN,GAAY4B,GAAehN,GAAS8L,GAAcgB;MAGjDnB,IAAkB1C,EACpB,UAAC7K,GAAOsN;QACJsB,EACIvB,EAAczL,GAAS;UAAE5B;QAAAA,IACzB,CAACA,EAAMuC,IAAImM,EAAOG,MAAM7O,EAAM0C,IAAIgM,EAAOI,MACzC,QAEJ9B,EAAWhN,IACX2N,KAAeA,EAAY3N,GAAOsN;MAAAA,GAEtC,CAACN,GAAY4B,GAAehN,GAAS+L;MAGnCH,IAAmB3C,EACrB,UAAC7K,GAAOsN;QACJH,KACAH,EAAW,OACXY,KAAgBA,EAAa5N,GAAOsN;MAAAA,GAExC,CAACH,GAAaH,GAAYY;MAGxBmB,IAAclE,EAChB,UAAC7K,GAAOsN;QACJqB,KAAWA,EAAQ3O,GAAOsN;MAAAA,GAE9B,CAACqB;IAAAA,OAID1O,EAAC+O;MACGC,OAAOzN;MACPkG,OAAOA;MACPC,QAAQA;MACR+F,cAAcN;MACdO,aAAaJ;MACbK,cAAcJ;MACdmB,SAASI;MACTjC,OAAOA;IAAAA;EAAAA;AAKnB2B,GAAK9N,YAAY;EACba,QAAQZ,EAAUsB,QAAQtB,EAAUC,QAAQC;EAC5C4G,OAAO9G,EAAU0B,OAAOxB;EACxB6G,QAAQ/G,EAAU0B,OAAOxB;EACzB4N,QAAQ9N,EAAUC,OAAOC;EACzBkM,YAAYpM,EAAUiC,KAAK/B;EAC3B4M,cAAc9M,EAAUiC;EACxB8K,aAAa/M,EAAUiC;EACvB+K,cAAchN,EAAUiC;EACxB8L,SAAS/N,EAAUiC;EACnBjB,SAAShB,EAAUwB,UAAU,CAACxB,EAAUiC,MAAMjC,EAAUC,SAASC;EACjEgM,OAAOlM,EAAU6C,KAAK3C;AAAAA;AAG1B,SAAeC,EAAK0N;ECrEdS,KAAO;IAAAC,IAEL9O,IAkEA8O,EAlEA9O;MACQ2I,IAiERmG,EAjEAxM;MACAC,IAgEAuM,EAhEAvM;MACQqG,IA+DRkG,EA/DArM;MACAC,IA8DAoM,EA9DApM;MACAC,IA6DAmM,EA7DAnM;MACAC,IA4DAkM,EA5DAlM;MACA6B,IA2DAqK,EA3DArK;MAEAN,IAyDA2K,EAzDA3K;MAEQ4K,IAuDRD,EAvDAT;MACAhH,IAsDAyH,EAtDAzH;MACAC,IAqDAwH,EArDAxH;MAEAxE,IAmDAgM,EAnDAhM;MACAE,IAkDA8L,EAlDA9L;MACAC,IAiDA6L,EAjDA7L;MACAC,IAgDA4L,EAhDA5L;MACAC,IA+CA2L,EA/CA3L;MACAE,IA8CAyL,EA9CAzL;MACAC,IA6CAwL,EA7CAxL;MACAC,IA4CAuL,EA5CAvL;MAEAmB,IA0CAoK,EA1CApK;MACAL,IAyCAyK,EAzCAzK;MACAC,IAwCAwK,EAxCAxK;MACAC,IAuCAuK,EAvCAvK;MAEAf,IAqCAsL,EArCAtL;MACAC,IAoCAqL,EApCArL;MACAC,IAmCAoL,EAnCApL;MACAC,IAkCAmL,EAlCAnL;MACAE,IAiCAiL,EAjCAjL;MACAC,IAgCAgL,EAhCAhL;MACAC,IA+BA+K,EA/BA/K;MACAC,IA8BA8K,EA9BA9K;MACAgL,IA6BAF,EA7BAE;MAEA3I,IA2BAyI,EA3BAzI;MACAC,IA0BAwI,EA1BAxI;MAEArC,IAwBA6K,EAxBA7K;MAEAU,IAsBAmK,EAtBAnK;MAEAE,IAoBAiK,EApBAjK;MAEAS,IAkBAwJ,EAlBAxJ;MACAR,IAiBAgK,EAjBAhK;MAEAuI,KAeAyB,EAfAzB;MACAC,KAcAwB,EAdAxB;MACAC,KAaAuB,EAbAvB;MACAe,KAYAQ,EAZAR;MAEA/M,KAUAuN,EAVAvN;MAEAwD,KAQA+J,EARA/J;MACAC,KAOA8J,EAPA9J;MACAC,KAMA6J,EANA7J;MAEAC,KAIA4J,EAJA5J;MACAC,KAGA2J,EAHA3J;MAEAE,KACAyJ,EADAzJ;MAAAA,KAGiE4J,EACjE5H,GACAC,GACAyH;MAHIV;MAAQa;MAAYC;MAAaC;MAAYC;MAAAA,KAgBjD3G,GAAQ;QACR1I;QACAsC,QAAQqG;QACRpG;QACAE,QAAQmG;QACRlG;QACA2E,OAAO6H;QACP5H,QAAQ6H;QACRhL;QACAvB;QACA6B;QACAd;QACAG;QACAiB;MAAAA;MAtBAsF;MACAE;MACAU;MACAC;MACApB;MACAxH;MACAG;MACA0F;MACAhH;MAiBEL,KAAQC;MACRoI,KAAgBC,EAAkBzF,GAAY7C;MAC9CuI,KAAsBD,EAAkBtF,GAAkBhD;MAAAA,KAExBwI,EAAS;MAA1CgG;MAAcC;MAAAA,KACmBjG,EAAS;MAA1CkG;MAAcC;MAEfC,KAAY;QACdC,MACI/P,EAACgQ;UAEG9O,OAAOA;UACPuG,OAAO6H;UACP5H,QAAQ6H;UACR7M,QAAQa,IAAcb,KAAS;UAC/BG,QAAQY,IAAcZ,KAAS;UAC/BoN,SAASvM;UACTwM,SAASvM;QAAAA,GAPL;QAUZU,SACIrE,EAACmQ;UAEG9L,SAASA;UACToD,OAAO6H;UACP5H,QAAQ6H;UACR7M,QAAQA;UACRG,QAAQA;UACR3B,OAAOA;QAAAA,GANH;QASZkP,MACIpQ,EAACqQ;UAEG3N,QAAQA;UACRG,QAAQA;UACR4E,OAAO6H;UACP5H,QAAQ6H;UACRrO,OAAOA;UACP2N,KAAK3L;UACLoN,OAAOlN;UACPmN,QAAQlN;UACRuL,MAAMtL;QAAAA,GATF;QAYZkN,OAAO;QACPjE,OACIvM,EAAC2M;UAAkBJ,OAAOrC;UAAQmB,eAAeA;UAAevG,WAAWA;QAAAA,GAAhE;QAEfyD,QAAQ;QACRhH,QAAQ;QACRkP,WAAW;QACXC,MAAM;QACN3L,SAASA,EAAQvD,IAAI,UAACmP,GAAQrI;UAAAA,OAC1BtI,EAAC4Q,UAEOD;YACJE,gBAAgBvB;YAChBwB,iBAAiBvB;YACjBnP,MAAMuQ,EAAOvQ,QAAQqK;YACrBvJ,OAAOA;YACPyJ,aAAagG,EAAOhG,cAAcA,UAAcoG;UAAAA,gBANjCzI;QAAAA;MAAAA;MAWrB0I,KAAYC,EAASxK,GAAMyD,IAAQxD;IAAAA,OAErCjC,MACAqL,GAAUU,QACNxQ,EAACqM;MAEGf,eAAeA;MACf5G,aAAaA;MACbC,eAAeA;MACf4H,OAAOrC;IAAAA,GAJH,WASZjF,MAAkC,MAAjBE,OACjB2K,GAAUvH,SACNvI,EAAC4N;MAEGrF,QAAQA;MACRtH,MAAMkE;MACN0H,OAAOzH;MACPsC,QAAQ6H;MACR5N,SAAS0D;MACTwI,SAAS+B;MACT7C,YAAY8C;IAAAA,GAPR,YAYZjM,MACAkM,GAAUvO,SACNvB,EAAC8N;MAEGvM,QAAQA;MACRwM,QAAQlK;MACRmK,MAAMlK;MACNtD,OAAO+I;MACP0E,aAAahK;MACbkH,aAAa1B;MACbyE,aAAa/J;MACbiG,OAAOhG;MACP+J,cAAciB;IAAAA,GATV,YAcZnK,KAAiBK,OACI,SAAjBoK,OACAI,GAAUW,YACNzQ,EAACkR;MAEGzJ,OAAO6H;MACP5H,QAAQ6H;MACRjN,GAAGoN,GAAapN;MAChBG,GAAGiN,GAAajN;MAChBuD,MAAMT;IAAAA,GALF,eASK,SAAjBqK,OACAE,GAAUW,YACNzQ,EAACkR;MAEGzJ,OAAO6H;MACP5H,QAAQ6H;MACRjN,GAAGsN,GAAatN;MAChBG,GAAGmN,GAAanN;MAChBuD,MAAMb;IAAAA,GALF,gBAWhBF,KAAiBS,MAA4B,MAAjBP,OAC5B2K,GAAUY,OACN1Q,EAACwO;MAEGjN,QAAQA;MACRkG,OAAO6H;MACP5H,QAAQ6H;MACRd,QAAQA;MACRZ,SAAS6B;MACT3C,YAAY4C;MACZlC,cAAcA;MACdC,aAAaA;MACbC,cAAcA;MACde,SAASA;MACT/M,SAASA;MACTkL,OAAO3H;IAAAA,GAZH,UAkBZlF,EAACmR;MACG1K,MAAMuK;MACNvJ,OAAO+H;MACP9H,QAAQ+H;MACRhB,QAAQA;MACRhJ,MAAMA;MAAAA,UAEL1C,EAAOvB,IAAI,UAAC4P,GAAO9I;QAAAA,OACK,qBAAV8I,IAEHpR,EAACqR;UAAAA,UACID,SACMlC;YACHI;YACAC;YACArF;YACA3B;YACAhH;YACAmB;YACAG;YACAwI;YACAC;YACAoE;YACAC;YACAC;YACAC;UAAAA;QAAAA,GAfOvH,KAqBhBwH,GAAUsB;MAAAA;IAAAA;EAAAA;AAMjCnC,GAAKvO,YAAY8E,IACjByJ,GAAKqC,eAAehL;AAEpB,SAAeiL,EAActC;EChUvBuC,KAAiB;IAAAtC,OACnBlP,EAACyR;MAAAA,UACI;QAAA,IAAGhK;UAAOC;QAAAA,OAAa1H,EAACiP;UAAKxH,OAAOA;UAAOC,QAAQA;QAAAA,GAAYwH;MAAAA;IAAAA;EAAAA;ECUlEwC,KAAa;IAAA,IACfjK;MACAC;MACQyH,MAARV;MACA3I;MAEA1F;MACQ2I,MAARrG;MACAC;MACQqG,MAARnG;MACAC;MACAE;MAEAD;MAEAwB;MACAO;MAEAL;MACAI;MACAH;MAEAd;MACAE;MACAC;MACAE;MACAC;MAEAX;MACAG;MACAD;MACAE;MACAT;MACAE;MACAC;MACAC;MAEAyB;MAEAE;MACAC;MAGAyI;MACAe;MACA/M;MAEAgQ;MAEMC,IAAWC,EAAO;MAAAC,IAC6CzC,EACjE5H,GACAC,GACAyH;MAHIV;MAAQa;MAAYC;MAAaC;MAAYC;MAK/CvO,KAAQC;MAAAA,KAC0BuI,EAAS;MAA1CgG;MAAcC;MAAAA,KAEoD7G,GAAQ;QAC7E1I;QACAsC,QAAQqG;QACRpG;QACAE,QAAQmG;QACRlG;QACA2E,OAAO6H;QACP5H,QAAQ6H;QACRhL;QACAvB;QACA6B;QACAd;QACAG;MAAAA;MAZImH;MAAeC;MAAepB;MAAQxH;MAAQG;MAAQtB;MAAAA,KAehCwQ,EAAe;QACzCxQ;QACAkG,OAAO6H;QACP5H,QAAQ6H;QACR1C,OAAO3H;MAAAA;MAJH8M;MAAUC;IAOlBC,EAAU;MACFP,MACAA,EAAU9D,UAAU+D,EAAS/D,UAGjC+D,EAAS/D,QAAQpG,QAAQ+H,KAAa1J,GACtC8L,EAAS/D,QAAQnG,SAAS+H,KAAc3J;MAAAA,IAElCqM,IAAMP,EAAS/D,QAAQuE,WAAW;MAExCD,EAAIE,MAAMvM,GAAYA,IAEtBqM,EAAIG,YAAYpR,GAAMqR,YACtBJ,EAAIK,SAAS,GAAG,GAAGhD,IAAYC,KAC/B0C,EAAIM,UAAUhE,GAAOG,MAAMH,GAAOI,MAElC9L,EAAO6E,QAAQ;QAAAwJ,IACU,qBAAVA,KACPA,EAAM;UACFe;UACA7C;UACAC;UACArF;UACA3I;UACAmB;UACAG;UACAiC;UACAuG;UACAC;UACAoE;UACAC;QAAAA,IAIM,WAAVyB,KAAoBlQ,GAAM6O,KAAK/I,KAAKmF,cAAc,MAClDgG,EAAIrN,YAAY5D,GAAM6O,KAAK/I,KAAKmF,aAChCgG,EAAIO,cAAcxR,GAAM6O,KAAK/I,KAAK0F,QAElCnJ,KACIoP,EAAwBR,GAAK;UACzB1K,OAAO6H;UACP5H,QAAQ6H;UACR8C,OAAO3P;UACPzB,MAAM;UACN2R,QAAQlP;QAAAA,IAGhBD,KACIkP,EAAwBR,GAAK;UACzB1K,OAAO6H;UACP5H,QAAQ6H;UACR8C,OAAOxP;UACP5B,MAAM;UACN2R,QAAQjP;QAAAA,KAIN,WAAVyN,KACAyB,EAAmBV,GAAK;UACpBzP;UACAG;UACA4E,OAAO6H;UACP5H,QAAQ6H;UACRV,KAAK3L;UACLoN,OAAOlN;UACPmN,QAAQlN;UACRuL,MAAMtL;UACNpC;QAAAA,IAIM,YAAVkQ,MAAoC,MAAf3M,MACrB0N,EAAIW,QACJX,EAAIY,cAAcrO,GAElB4G,GAAc0H,QAAQb,IACtBjI,GAAOtC,QAAQ;UACXuK,EAAIG,YAAY/H,EAAM/J,OACtB2R,EAAIc,aACJ3H,GAAcf,EAAMnK,KAAKoB,IAAI;YAAA0F,OAAKA,EAAE8D;UAAAA,KACpCmH,EAAIzL;QAAAA,IAGRyL,EAAIe,YAGM,YAAV9B,MACA/F,GAAc2H,QAAQb,IACtBjI,GAAOtC,QAAQ;UACXuK,EAAIO,cAAcnI,EAAM/J,OACxB2R,EAAIrN,YAAYA,GAChBqN,EAAIc,aACJ5H,GAAcd,EAAMnK,KAAKoB,IAAI;YAAA0F,OAAKA,EAAE8D;UAAAA,KACpCmH,EAAIzF;QAAAA,KAIE,aAAV0E,MAAuC,MAAjBxN,KAAyBE,IAAY,KAC3DvC,GAAOqG,QAAQ;UACXuK,EAAIG,YAAYvS,EAAMS,OACtB2R,EAAIc,aACJd,EAAIgB,IAAIpT,EAAMuC,GAAGvC,EAAM0C,GAAGqB,IAAY,GAAG,GAAG,IAAIsP,KAAKC,KACrDlB,EAAIzL,QAEAzC,IAAmB,MACnBkO,EAAIO,cAAc3S,EAAMoL,aACxBgH,EAAIrN,YAAYb,GAChBkO,EAAIzF;QAAAA,IAKF,WAAV0E,MAAkC,MAAdlM,MACpBoO,GAAsBnB,GAAKF,KACvBvC,MACA6D,GAA0BpB,GAAKF,IAASvC,GAAazE,SAI/C,cAAVmG,GAAqB;UAAA,IACf3G,IAAaP,GACd1I,IAAI;YAAA+I,OAAU;cACXrK,IAAIqK,EAAMrK;cACVkK,OAAOG,EAAMrK;cACbM,OAAO+J,EAAM/J;YAAAA;UAAAA,GAEhBoI;UAEL7D,EAAQ6C,QAAQ;YACZ4L,EAAqBrB,UACdxB;cACHvQ,MAAMuQ,EAAOvQ,QAAQqK;cACrBoG,gBAAgBvB;cAChBwB,iBAAiBvB;cACjBrO;YAAAA;UAAAA;QAAAA;MAAAA;IAAAA,GAKjB,CACC0Q,GACApC,IACAC,IACA1M,GACA7B,IACAmK,IACAnB,IACAxH,IACAG,IACAU,GACAG,GACAD,GACAE,GACAT,GACAE,GACAC,GACAC,GACAyB,GACAxD,IACAqC,GACAE,GACA4L;IAAAA,IAGE+D,KAAyB7I,EAC3B;QAAAyC,QACmBqG,EAAkB9B,EAAS/D,SAASR;UAA5C/K;UAAGG;QAAAA,KACLkR,EAAelF,GAAOG,MAAMH,GAAOI,KAAKS,IAAYC,IAAajN,GAAGG,IAAI,OAAO;QAAA,IAE9EmR,IAAa5B,GAAS1H,KAAKhI,IAAImM,GAAOG,MAAMnM,IAAIgM,GAAOI;QAAAA,OACtDtN,GAAOqS;MAAAA,GAElB,CAAChC,GAAUnD,IAAQa,IAAYC,IAAayC;MAAAA,KAGFhF;MAAtCC;MAAsBC;MAExB2G,KAAmBjJ,EACrB;QAAAyC,IACUtN,IAAQ0T,GAAuBpG;QACrCsC,GAAgB5P,IAEZA,IACAkN,GAAqBG,EAAczL,GAAS;UAAE5B;QAAAA,IAAUsN,KAExDH;MAAAA,GAGR,CAACuG,IAAwB9D,IAAiB1C,IAAsBC,IAAavL;MAG3E4L,KAAmB3C,EACrB;QACIsC,MACAyC,GAAgB,OAChBD,MAAgB/B,KAAgBA,EAAa+B,IAAcrC;MAAAA,GAE/D,CAACH,IAAayC,IAAiBhC;MAG7BmB,KAAclE,EAChB;QAAAyC,IACQqB,GAAS;UAAA,IACH3O,IAAQ0T,GAAuBpG;UACrCtN,KAAS2O,EAAQ3O,GAAOsN;QAAAA;MAAAA,GAGhC,CAACoG,IAAwB/E;IAAAA,OAIzB1O;MACI8T,KAAKlC;MACLnK,OAAO+H,KAAa1J;MACpB4B,QAAQ+H,KAAc3J;MACtBpE,OAAO;QACH+F,OAAO+H;QACP9H,QAAQ+H;QACRsE,QAAQ9O,IAAgB,SAAS;MAAA;MAErCwI,cAAcxI,IAAgB4O,UAAmB9C;MACjDrD,aAAazI,IAAgB4O,UAAmB9C;MAChDpD,cAAc1I,IAAgBsI,UAAmBwD;MACjDrC,SAASzJ,IAAgB6J,UAAciC;IAAAA;EAAAA;AAKnDW,GAAWhR,YAAYmF,IACvB6L,GAAWJ,eAAe3K;AAE1B,IAAMqN,KAA0BzC,EAAcG;EAAAA,KAE/BuC,EAAW,UAAC/E,GAAO4E;IAAAA,OAAQ9T,EAACgU,WAA4B9E;MAAOyC,WAAWmC;IAAAA;EAAAA;EAAAA,KC9T1EG,EANc,UAAC/E,GAAO4E;IAAAA,OACjC9T,EAACyR;MAAAA,UACI;QAAA,IAAGhK;UAAOC;QAAAA,OAAa1H,EAAC0R;UAAWjK,OAAOA;UAAOC,QAAQA;QAAAA,GAAYwH;UAAO4E,KAAKA;QAAAA;MAAAA;IAAAA;EAAAA;AAAAA","names":["LinePointTooltip","point","_jsx","BasicTooltip","id","_jsxs","data","xFormatted","yFormatted","enableChip","color","serieColor","propTypes","PropTypes","object","isRequired","memo","SliceTooltip","slice","axis","theme","useTheme","otherAxis","TableTooltip","rows","points","map","Chip","style","tooltip","chip","serieId","tableCellValue","oneOf","commonPropTypes","arrayOf","shape","oneOfType","string","number","x","instanceOf","Date","y","xScale","xFormat","func","yScale","yFormat","layers","curve","lineCurvePropType","axisTop","axisPropType","axisRight","axisBottom","axisLeft","enableGridX","bool","enableGridY","gridXValues","gridYValues","enablePoints","pointSymbol","pointSize","pointColor","any","pointBorderWidth","pointBorderColor","enablePointLabel","pointLabel","markers","value","colors","ordinalColorsPropType","enableArea","areaOpacity","areaBlendMode","blendModePropType","areaBaselineValue","lineWidth","legends","LegendPropShape","isInteractive","debugMesh","enableSlices","debugSlices","sliceTooltip","enableCrosshair","crosshairType","LinePropTypes","role","useMesh","motionPropTypes","defsPropTypes","LineCanvasPropTypes","pixelRatio","commonDefaultProps","type","min","max","from","scheme","PointTooltip","LineDefaultProps","animate","motionConfig","defs","fill","LineCanvasDefaultProps","window","devicePixelRatio","useLineGenerator","useMemo","line","defined","d","curveFromProp","useAreaGenerator","area","y1","y0","useSlices","width","height","Map","forEach","has","get","push","set","Array","entries","sort","a","b","i","slices","x0","slicePoints","prevSlice","nextSlice","reverse","sliceHeight","useLine","xScaleSpec","yScaleSpec","enableSlicesTooltip","formatX","useValueFormatter","formatY","getColor","useOrdinalColorScale","getPointColor","useInheritedColor","getPointBorderColor","useState","hiddenIds","setHiddenIds","computeXYScalesForSeries","filter","item","indexOf","rawSeries","series","dataWithColor","label","datum","find","serie","Boolean","legendData","hidden","toggleSerie","useCallback","state","reduce","acc","position","index","length","borderColor","usePoints","lineGenerator","areaGenerator","AreaPath","path","useMotionConfig","springConfig","config","animatedPath","useAnimatedPath","animatedProps","useSpring","immediate","animated","fillOpacity","strokeWidth","mixBlendMode","Areas","computedLines","lines","LinesItem","thickness","stroke","Lines","SlicesItem","debug","isCurrent","setCurrent","useTooltip","showTooltipFromEvent","hideTooltip","handleMouseEnter","createElement","event","handleMouseMove","handleMouseLeave","strokeOpacity","onMouseEnter","onMouseMove","onMouseLeave","Slices","current","Points","symbol","size","borderWidth","enableLabel","labelYOffset","getLabel","getLabelGenerator","mappedPoints","DotsItem","Mesh","margin","onClick","showTooltipAt","left","top","handleClick","BaseMesh","nodes","Line","props","partialMargin","pointLabelYOffset","useDimensions","innerWidth","innerHeight","outerWidth","outerHeight","currentPoint","setCurrentPoint","currentSlice","setCurrentSlice","layerById","grid","Grid","xValues","yValues","CartesianMarkers","axes","Axes","right","bottom","areas","crosshair","mesh","legend","BoxLegendSvg","containerWidth","containerHeight","undefined","boundDefs","bindDefs","Crosshair","SvgWrapper","layer","Fragment","defaultProps","withContainer","ResponsiveLine","ResponsiveWrapper","LineCanvas","canvasRef","canvasEl","useRef","$","useVoronoiMesh","delaunay","voronoi","useEffect","ctx","getContext","scale","fillStyle","background","fillRect","translate","strokeStyle","renderGridLinesToCanvas","values","renderAxesToCanvas","save","globalAlpha","context","beginPath","restore","arc","Math","PI","renderVoronoiToCanvas","renderVoronoiCellToCanvas","renderLegendToCanvas","getPointFromMouseEvent","getRelativeCursor","isCursorInRect","pointIndex","handleMouseHover","ref","cursor","LineCanvasWithContainer","forwardRef"],"sources":["/Users/pratyushgarg/Downloads/Web Development/density-final-frontend/node_modules/@nivo/line/src/PointTooltip.js","/Users/pratyushgarg/Downloads/Web Development/density-final-frontend/node_modules/@nivo/line/src/SliceTooltip.js","/Users/pratyushgarg/Downloads/Web Development/density-final-frontend/node_modules/@nivo/line/src/props.js","/Users/pratyushgarg/Downloads/Web Development/density-final-frontend/node_modules/@nivo/line/src/hooks.js","/Users/pratyushgarg/Downloads/Web Development/density-final-frontend/node_modules/@nivo/line/src/Areas.js","/Users/pratyushgarg/Downloads/Web Development/density-final-frontend/node_modules/@nivo/line/src/LinesItem.js","/Users/pratyushgarg/Downloads/Web Development/density-final-frontend/node_modules/@nivo/line/src/Lines.js","/Users/pratyushgarg/Downloads/Web Development/density-final-frontend/node_modules/@nivo/line/src/SlicesItem.js","/Users/pratyushgarg/Downloads/Web Development/density-final-frontend/node_modules/@nivo/line/src/Slices.js","/Users/pratyushgarg/Downloads/Web Development/density-final-frontend/node_modules/@nivo/line/src/Points.js","/Users/pratyushgarg/Downloads/Web Development/density-final-frontend/node_modules/@nivo/line/src/Mesh.js","/Users/pratyushgarg/Downloads/Web Development/density-final-frontend/node_modules/@nivo/line/src/Line.js","/Users/pratyushgarg/Downloads/Web Development/density-final-frontend/node_modules/@nivo/line/src/ResponsiveLine.js","/Users/pratyushgarg/Downloads/Web Development/density-final-frontend/node_modules/@nivo/line/src/LineCanvas.js","/Users/pratyushgarg/Downloads/Web Development/density-final-frontend/node_modules/@nivo/line/src/ResponsiveLineCanvas.js"],"sourcesContent":["/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo } from 'react'\nimport PropTypes from 'prop-types'\nimport { BasicTooltip } from '@nivo/tooltip'\n\nconst LinePointTooltip = ({ point }) => {\n    return (\n        <BasicTooltip\n            id={\n                <span>\n                    x: <strong>{point.data.xFormatted}</strong>, y:{' '}\n                    <strong>{point.data.yFormatted}</strong>\n                </span>\n            }\n            enableChip={true}\n            color={point.serieColor}\n        />\n    )\n}\n\nLinePointTooltip.propTypes = {\n    point: PropTypes.object.isRequired,\n}\n\nexport default memo(LinePointTooltip)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo } from 'react'\nimport PropTypes from 'prop-types'\nimport { useTheme } from '@nivo/core'\nimport { Chip, TableTooltip } from '@nivo/tooltip'\n\nconst SliceTooltip = ({ slice, axis }) => {\n    const theme = useTheme()\n    const otherAxis = axis === 'x' ? 'y' : 'x'\n\n    return (\n        <TableTooltip\n            rows={slice.points.map(point => [\n                <Chip key=\"chip\" color={point.serieColor} style={theme.tooltip.chip} />,\n                point.serieId,\n                <span key=\"value\" style={theme.tooltip.tableCellValue}>\n                    {point.data[`${otherAxis}Formatted`]}\n                </span>,\n            ])}\n        />\n    )\n}\n\nSliceTooltip.propTypes = {\n    slice: PropTypes.object.isRequired,\n    axis: PropTypes.oneOf(['x', 'y']).isRequired,\n}\n\nexport default memo(SliceTooltip)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport PropTypes from 'prop-types'\nimport { lineCurvePropType, blendModePropType, motionPropTypes, defsPropTypes } from '@nivo/core'\nimport { ordinalColorsPropType } from '@nivo/colors'\nimport { axisPropType } from '@nivo/axes'\nimport { LegendPropShape } from '@nivo/legends'\nimport PointTooltip from './PointTooltip'\nimport SliceTooltip from './SliceTooltip'\n\nconst commonPropTypes = {\n    data: PropTypes.arrayOf(\n        PropTypes.shape({\n            id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,\n            data: PropTypes.arrayOf(\n                PropTypes.shape({\n                    x: PropTypes.oneOfType([\n                        PropTypes.number,\n                        PropTypes.string,\n                        PropTypes.instanceOf(Date),\n                    ]),\n                    y: PropTypes.oneOfType([\n                        PropTypes.number,\n                        PropTypes.string,\n                        PropTypes.instanceOf(Date),\n                    ]),\n                })\n            ).isRequired,\n        })\n    ).isRequired,\n\n    xScale: PropTypes.object.isRequired,\n    xFormat: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n    yScale: PropTypes.object.isRequired,\n    yFormat: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n\n    layers: PropTypes.arrayOf(\n        PropTypes.oneOfType([\n            PropTypes.oneOf([\n                'grid',\n                'markers',\n                'axes',\n                'areas',\n                'crosshair',\n                'lines',\n                'slices',\n                'points',\n                'mesh',\n                'legends',\n            ]),\n            PropTypes.func,\n        ])\n    ).isRequired,\n\n    curve: lineCurvePropType.isRequired,\n\n    axisTop: axisPropType,\n    axisRight: axisPropType,\n    axisBottom: axisPropType,\n    axisLeft: axisPropType,\n\n    enableGridX: PropTypes.bool.isRequired,\n    enableGridY: PropTypes.bool.isRequired,\n    gridXValues: PropTypes.oneOfType([\n        PropTypes.number,\n        PropTypes.arrayOf(\n            PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)])\n        ),\n    ]),\n    gridYValues: PropTypes.oneOfType([\n        PropTypes.number,\n        PropTypes.arrayOf(\n            PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)])\n        ),\n    ]),\n\n    enablePoints: PropTypes.bool.isRequired,\n    pointSymbol: PropTypes.func,\n    pointSize: PropTypes.number.isRequired,\n    pointColor: PropTypes.any.isRequired,\n    pointBorderWidth: PropTypes.number.isRequired,\n    pointBorderColor: PropTypes.any.isRequired,\n    enablePointLabel: PropTypes.bool.isRequired,\n    pointLabel: PropTypes.oneOfType([PropTypes.string, PropTypes.func]).isRequired,\n\n    markers: PropTypes.arrayOf(\n        PropTypes.shape({\n            axis: PropTypes.oneOf(['x', 'y']).isRequired,\n            value: PropTypes.oneOfType([\n                PropTypes.number,\n                PropTypes.string,\n                PropTypes.instanceOf(Date),\n            ]).isRequired,\n            style: PropTypes.object,\n        })\n    ),\n\n    colors: ordinalColorsPropType.isRequired,\n\n    enableArea: PropTypes.bool.isRequired,\n    areaOpacity: PropTypes.number.isRequired,\n    areaBlendMode: blendModePropType.isRequired,\n    areaBaselineValue: PropTypes.oneOfType([\n        PropTypes.number,\n        PropTypes.string,\n        PropTypes.instanceOf(Date),\n    ]).isRequired,\n    lineWidth: PropTypes.number.isRequired,\n\n    legends: PropTypes.arrayOf(PropTypes.shape(LegendPropShape)).isRequired,\n\n    isInteractive: PropTypes.bool.isRequired,\n    debugMesh: PropTypes.bool.isRequired,\n\n    tooltip: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,\n\n    enableSlices: PropTypes.oneOf(['x', 'y', false]).isRequired,\n    debugSlices: PropTypes.bool.isRequired,\n    sliceTooltip: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,\n\n    enableCrosshair: PropTypes.bool.isRequired,\n    crosshairType: PropTypes.string.isRequired,\n}\n\nexport const LinePropTypes = {\n    ...commonPropTypes,\n    enablePointLabel: PropTypes.bool.isRequired,\n    role: PropTypes.string.isRequired,\n    useMesh: PropTypes.bool.isRequired,\n    ...motionPropTypes,\n    ...defsPropTypes,\n}\n\nexport const LineCanvasPropTypes = {\n    pixelRatio: PropTypes.number.isRequired,\n    ...commonPropTypes,\n}\n\nconst commonDefaultProps = {\n    curve: 'linear',\n\n    xScale: {\n        type: 'point',\n    },\n    yScale: {\n        type: 'linear',\n        min: 0,\n        max: 'auto',\n    },\n\n    layers: [\n        'grid',\n        'markers',\n        'axes',\n        'areas',\n        'crosshair',\n        'lines',\n        'points',\n        'slices',\n        'mesh',\n        'legends',\n    ],\n    axisBottom: {},\n    axisLeft: {},\n    enableGridX: true,\n    enableGridY: true,\n\n    enablePoints: true,\n    pointSize: 6,\n    pointColor: { from: 'color' },\n    pointBorderWidth: 0,\n    pointBorderColor: { theme: 'background' },\n    enablePointLabel: false,\n    pointLabel: 'yFormatted',\n\n    colors: { scheme: 'nivo' },\n    enableArea: false,\n    areaBaselineValue: 0,\n    areaOpacity: 0.2,\n    areaBlendMode: 'normal',\n    lineWidth: 2,\n\n    legends: [],\n\n    isInteractive: true,\n    tooltip: PointTooltip,\n    enableSlices: false,\n    debugSlices: false,\n    sliceTooltip: SliceTooltip,\n    debugMesh: false,\n    enableCrosshair: true,\n    crosshairType: 'bottom-left',\n}\n\nexport const LineDefaultProps = {\n    ...commonDefaultProps,\n    enablePointLabel: false,\n    useMesh: false,\n    animate: true,\n    motionConfig: 'gentle',\n    defs: [],\n    fill: [],\n    role: 'img',\n}\n\nexport const LineCanvasDefaultProps = {\n    ...commonDefaultProps,\n    pixelRatio: typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1,\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { useCallback, useMemo, useState } from 'react'\nimport { area, line } from 'd3-shape'\nimport { curveFromProp, useTheme, useValueFormatter } from '@nivo/core'\nimport { useOrdinalColorScale, useInheritedColor } from '@nivo/colors'\nimport { computeXYScalesForSeries } from '@nivo/scales'\nimport { LineDefaultProps } from './props'\n\nexport const useLineGenerator = ({ curve }) => {\n    return useMemo(\n        () =>\n            line()\n                .defined(d => d.x !== null && d.y !== null)\n                .x(d => d.x)\n                .y(d => d.y)\n                .curve(curveFromProp(curve)),\n        [curve]\n    )\n}\n\nexport const useAreaGenerator = ({ curve, yScale, areaBaselineValue }) => {\n    return useMemo(() => {\n        return area()\n            .defined(d => d.x !== null && d.y !== null)\n            .x(d => d.x)\n            .y1(d => d.y)\n            .curve(curveFromProp(curve))\n            .y0(yScale(areaBaselineValue))\n    }, [curve, yScale, areaBaselineValue])\n}\n\nconst usePoints = ({ series, getPointColor, getPointBorderColor, formatX, formatY }) => {\n    return useMemo(() => {\n        return series.reduce((acc, serie) => {\n            return [\n                ...acc,\n                ...serie.data\n                    .filter(datum => datum.position.x !== null && datum.position.y !== null)\n                    .map((datum, i) => {\n                        const point = {\n                            id: `${serie.id}.${i}`,\n                            index: acc.length + i,\n                            serieId: serie.id,\n                            serieColor: serie.color,\n                            x: datum.position.x,\n                            y: datum.position.y,\n                        }\n                        point.color = getPointColor(serie)\n                        point.borderColor = getPointBorderColor(point)\n                        point.data = {\n                            ...datum.data,\n                            xFormatted: formatX(datum.data.x),\n                            yFormatted: formatY(datum.data.y),\n                        }\n\n                        return point\n                    }),\n            ]\n        }, [])\n    }, [series, getPointColor, getPointBorderColor, formatX, formatY])\n}\n\nexport const useSlices = ({ enableSlices, points, width, height }) => {\n    return useMemo(() => {\n        if (enableSlices === false) return []\n\n        if (enableSlices === 'x') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.x)) map.set(point.x, [point])\n                else map.get(point.x).push(point)\n            })\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([x, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let x0\n                    if (!prevSlice) x0 = x\n                    else x0 = x - (x - prevSlice[0]) / 2\n\n                    let sliceWidth\n                    if (!nextSlice) sliceWidth = width - x0\n                    else sliceWidth = x - x0 + (nextSlice[0] - x) / 2\n\n                    return {\n                        id: x,\n                        x0,\n                        x,\n                        y0: 0,\n                        y: 0,\n                        width: sliceWidth,\n                        height,\n                        points: slicePoints.reverse(),\n                    }\n                })\n        } else if (enableSlices === 'y') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.y)) map.set(point.y, [point])\n                else map.get(point.y).push(point)\n            })\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([y, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let y0\n                    if (!prevSlice) y0 = y\n                    else y0 = y - (y - prevSlice[0]) / 2\n\n                    let sliceHeight\n                    if (!nextSlice) sliceHeight = height - y0\n                    else sliceHeight = y - y0 + (nextSlice[0] - y) / 2\n\n                    return {\n                        id: y,\n                        x0: 0,\n                        x: 0,\n                        y0,\n                        y,\n                        width,\n                        height: sliceHeight,\n                        points: slicePoints.reverse(),\n                    }\n                })\n        }\n    }, [enableSlices, points])\n}\n\nexport const useLine = ({\n    data,\n    xScale: xScaleSpec = LineDefaultProps.xScale,\n    xFormat,\n    yScale: yScaleSpec = LineDefaultProps.yScale,\n    yFormat,\n    width,\n    height,\n    colors = LineDefaultProps.colors,\n    curve = LineDefaultProps.curve,\n    areaBaselineValue = LineDefaultProps.areaBaselineValue,\n    pointColor = LineDefaultProps.pointColor,\n    pointBorderColor = LineDefaultProps.pointBorderColor,\n    enableSlices = LineDefaultProps.enableSlicesTooltip,\n}) => {\n    const formatX = useValueFormatter(xFormat)\n    const formatY = useValueFormatter(yFormat)\n    const getColor = useOrdinalColorScale(colors, 'id')\n    const theme = useTheme()\n    const getPointColor = useInheritedColor(pointColor, theme)\n    const getPointBorderColor = useInheritedColor(pointBorderColor, theme)\n    const [hiddenIds, setHiddenIds] = useState([])\n\n    const {\n        xScale,\n        yScale,\n        series: rawSeries,\n    } = useMemo(\n        () =>\n            computeXYScalesForSeries(\n                data.filter(item => hiddenIds.indexOf(item.id) === -1),\n                xScaleSpec,\n                yScaleSpec,\n                width,\n                height\n            ),\n        [data, hiddenIds, xScaleSpec, yScaleSpec, width, height]\n    )\n\n    const { legendData, series } = useMemo(() => {\n        const dataWithColor = data.map(line => ({\n            id: line.id,\n            label: line.id,\n            color: getColor(line),\n        }))\n        const series = dataWithColor\n            .map(datum => ({\n                ...rawSeries.find(serie => serie.id === datum.id),\n                color: datum.color,\n            }))\n            .filter(item => Boolean(item.id))\n        const legendData = dataWithColor\n            .map(item => ({ ...item, hidden: !series.find(serie => serie.id === item.id) }))\n            .reverse()\n\n        return { legendData, series }\n    }, [data, rawSeries, getColor])\n\n    const toggleSerie = useCallback(id => {\n        setHiddenIds(state =>\n            state.indexOf(id) > -1 ? state.filter(item => item !== id) : [...state, id]\n        )\n    }, [])\n\n    const points = usePoints({\n        series,\n        getPointColor,\n        getPointBorderColor,\n        formatX,\n        formatY,\n    })\n\n    const slices = useSlices({\n        enableSlices,\n        points,\n        width,\n        height,\n    })\n\n    const lineGenerator = useLineGenerator({ curve })\n    const areaGenerator = useAreaGenerator({\n        curve,\n        yScale,\n        areaBaselineValue,\n    })\n\n    return {\n        legendData,\n        toggleSerie,\n        lineGenerator,\n        areaGenerator,\n        getColor,\n        series,\n        xScale,\n        yScale,\n        slices,\n        points,\n    }\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo } from 'react'\nimport PropTypes from 'prop-types'\nimport { useSpring, animated } from '@react-spring/web'\nimport { useAnimatedPath, useMotionConfig, blendModePropType } from '@nivo/core'\n\nconst AreaPath = ({ areaBlendMode, areaOpacity, color, fill, path }) => {\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedPath = useAnimatedPath(path)\n    const animatedProps = useSpring({\n        color,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.path\n            d={animatedPath}\n            fill={fill ? fill : animatedProps.color}\n            fillOpacity={areaOpacity}\n            strokeWidth={0}\n            style={{\n                mixBlendMode: areaBlendMode,\n            }}\n        />\n    )\n}\n\nAreaPath.propTypes = {\n    areaBlendMode: blendModePropType.isRequired,\n    areaOpacity: PropTypes.number.isRequired,\n    color: PropTypes.string,\n    fill: PropTypes.string,\n    path: PropTypes.string.isRequired,\n}\n\nconst Areas = ({ areaGenerator, areaOpacity, areaBlendMode, lines }) => {\n    const computedLines = lines.slice(0).reverse()\n\n    return (\n        <g>\n            {computedLines.map(line => (\n                <AreaPath\n                    key={line.id}\n                    path={areaGenerator(line.data.map(d => d.position))}\n                    {...{ areaOpacity, areaBlendMode, ...line }}\n                />\n            ))}\n        </g>\n    )\n}\n\nAreas.propTypes = {\n    areaGenerator: PropTypes.func.isRequired,\n    areaOpacity: PropTypes.number.isRequired,\n    areaBlendMode: blendModePropType.isRequired,\n    lines: PropTypes.arrayOf(PropTypes.object).isRequired,\n}\n\nexport default memo(Areas)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo, useMemo } from 'react'\nimport PropTypes from 'prop-types'\nimport { animated } from '@react-spring/web'\nimport { useAnimatedPath } from '@nivo/core'\n\nconst LinesItem = ({ lineGenerator, points, color, thickness }) => {\n    const path = useMemo(() => lineGenerator(points), [lineGenerator, points])\n    const animatedPath = useAnimatedPath(path)\n\n    return <animated.path d={animatedPath} fill=\"none\" strokeWidth={thickness} stroke={color} />\n}\n\nLinesItem.propTypes = {\n    points: PropTypes.arrayOf(\n        PropTypes.shape({\n            x: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n            y: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n        })\n    ),\n    lineGenerator: PropTypes.func.isRequired,\n    color: PropTypes.string.isRequired,\n    thickness: PropTypes.number.isRequired,\n}\n\nexport default memo(LinesItem)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo } from 'react'\nimport PropTypes from 'prop-types'\nimport LinesItem from './LinesItem'\n\nconst Lines = ({ lines, lineGenerator, lineWidth }) => {\n    return lines\n        .slice(0)\n        .reverse()\n        .map(({ id, data, color }) => (\n            <LinesItem\n                key={id}\n                id={id}\n                points={data.map(d => d.position)}\n                lineGenerator={lineGenerator}\n                color={color}\n                thickness={lineWidth}\n            />\n        ))\n}\n\nLines.propTypes = {\n    lines: PropTypes.arrayOf(\n        PropTypes.shape({\n            id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,\n            color: PropTypes.string.isRequired,\n            data: PropTypes.arrayOf(\n                PropTypes.shape({\n                    data: PropTypes.shape({\n                        x: PropTypes.oneOfType([\n                            PropTypes.string,\n                            PropTypes.number,\n                            PropTypes.instanceOf(Date),\n                        ]),\n                        y: PropTypes.oneOfType([\n                            PropTypes.string,\n                            PropTypes.number,\n                            PropTypes.instanceOf(Date),\n                        ]),\n                    }).isRequired,\n                    position: PropTypes.shape({\n                        x: PropTypes.number,\n                        y: PropTypes.number,\n                    }).isRequired,\n                })\n            ).isRequired,\n        })\n    ).isRequired,\n    lineWidth: PropTypes.number.isRequired,\n    lineGenerator: PropTypes.func.isRequired,\n}\n\nexport default memo(Lines)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { createElement, memo, useCallback } from 'react'\nimport PropTypes from 'prop-types'\nimport { useTooltip } from '@nivo/tooltip'\n\nconst SlicesItem = ({ slice, axis, debug, tooltip, isCurrent, setCurrent }) => {\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            setCurrent(slice)\n        },\n        [showTooltipFromEvent, tooltip, slice]\n    )\n\n    const handleMouseMove = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n        },\n        [showTooltipFromEvent, tooltip, slice]\n    )\n\n    const handleMouseLeave = useCallback(() => {\n        hideTooltip()\n        setCurrent(null)\n    }, [hideTooltip])\n\n    return (\n        <rect\n            x={slice.x0}\n            y={slice.y0}\n            width={slice.width}\n            height={slice.height}\n            stroke=\"red\"\n            strokeWidth={debug ? 1 : 0}\n            strokeOpacity={0.75}\n            fill=\"red\"\n            fillOpacity={isCurrent && debug ? 0.35 : 0}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n        />\n    )\n}\n\nSlicesItem.propTypes = {\n    slice: PropTypes.object.isRequired,\n    axis: PropTypes.oneOf(['x', 'y']).isRequired,\n    debug: PropTypes.bool.isRequired,\n    height: PropTypes.number.isRequired,\n    tooltip: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),\n    isCurrent: PropTypes.bool.isRequired,\n    setCurrent: PropTypes.func.isRequired,\n}\n\nexport default memo(SlicesItem)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo } from 'react'\nimport PropTypes from 'prop-types'\nimport SlicesItem from './SlicesItem'\n\nconst Slices = ({ slices, axis, debug, height, tooltip, current, setCurrent }) => {\n    return slices.map(slice => (\n        <SlicesItem\n            key={slice.id}\n            slice={slice}\n            axis={axis}\n            debug={debug}\n            height={height}\n            tooltip={tooltip}\n            setCurrent={setCurrent}\n            isCurrent={current !== null && current.id === slice.id}\n        />\n    ))\n}\n\nSlices.propTypes = {\n    slices: PropTypes.arrayOf(\n        PropTypes.shape({\n            id: PropTypes.oneOfType([\n                PropTypes.number,\n                PropTypes.string,\n                PropTypes.instanceOf(Date),\n            ]).isRequired,\n            x: PropTypes.number.isRequired,\n            y: PropTypes.number.isRequired,\n            points: PropTypes.arrayOf(PropTypes.object).isRequired,\n        })\n    ).isRequired,\n    axis: PropTypes.oneOf(['x', 'y']).isRequired,\n    debug: PropTypes.bool.isRequired,\n    height: PropTypes.number.isRequired,\n    tooltip: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,\n    current: PropTypes.object,\n    setCurrent: PropTypes.func.isRequired,\n}\n\nexport default memo(Slices)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { memo } from 'react'\nimport PropTypes from 'prop-types'\nimport { getLabelGenerator, DotsItem, useTheme } from '@nivo/core'\n\nconst Points = ({ points, symbol, size, borderWidth, enableLabel, label, labelYOffset }) => {\n    const theme = useTheme()\n    const getLabel = getLabelGenerator(label)\n\n    /**\n     * We reverse the `points` array so that points from the lower lines in stacked lines\n     * graph are drawn on top. See https://github.com/plouc/nivo/issues/1051.\n     */\n    const mappedPoints = points\n        .slice(0)\n        .reverse()\n        .map(point => {\n            const mappedPoint = {\n                id: point.id,\n                x: point.x,\n                y: point.y,\n                datum: point.data,\n                fill: point.color,\n                stroke: point.borderColor,\n                label: enableLabel ? getLabel(point.data) : null,\n            }\n\n            return mappedPoint\n        })\n\n    return (\n        <g>\n            {mappedPoints.map(point => (\n                <DotsItem\n                    key={point.id}\n                    x={point.x}\n                    y={point.y}\n                    datum={point.datum}\n                    symbol={symbol}\n                    size={size}\n                    color={point.fill}\n                    borderWidth={borderWidth}\n                    borderColor={point.stroke}\n                    label={point.label}\n                    labelYOffset={labelYOffset}\n                    theme={theme}\n                />\n            ))}\n        </g>\n    )\n}\n\nPoints.propTypes = {\n    points: PropTypes.arrayOf(PropTypes.object),\n    symbol: PropTypes.func,\n    size: PropTypes.number.isRequired,\n    color: PropTypes.func.isRequired,\n    borderWidth: PropTypes.number.isRequired,\n    borderColor: PropTypes.func.isRequired,\n    enableLabel: PropTypes.bool.isRequired,\n    label: PropTypes.oneOfType([PropTypes.string, PropTypes.func]).isRequired,\n    labelYOffset: PropTypes.number,\n}\n\nexport default memo(Points)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { createElement, memo, useCallback } from 'react'\nimport PropTypes from 'prop-types'\nimport { useTooltip } from '@nivo/tooltip'\nimport { Mesh as BaseMesh } from '@nivo/voronoi'\n\nconst Mesh = ({\n    points,\n    width,\n    height,\n    margin,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    tooltip,\n    debug,\n}) => {\n    const { showTooltipAt, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            setCurrent(point)\n            onMouseEnter && onMouseEnter(point, event)\n        },\n        [setCurrent, showTooltipAt, tooltip, onMouseEnter, margin]\n    )\n\n    const handleMouseMove = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            setCurrent(point)\n            onMouseMove && onMouseMove(point, event)\n        },\n        [setCurrent, showTooltipAt, tooltip, onMouseMove]\n    )\n\n    const handleMouseLeave = useCallback(\n        (point, event) => {\n            hideTooltip()\n            setCurrent(null)\n            onMouseLeave && onMouseLeave(point, event)\n        },\n        [hideTooltip, setCurrent, onMouseLeave]\n    )\n\n    const handleClick = useCallback(\n        (point, event) => {\n            onClick && onClick(point, event)\n        },\n        [onClick]\n    )\n\n    return (\n        <BaseMesh\n            nodes={points}\n            width={width}\n            height={height}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onClick={handleClick}\n            debug={debug}\n        />\n    )\n}\n\nMesh.propTypes = {\n    points: PropTypes.arrayOf(PropTypes.object).isRequired,\n    width: PropTypes.number.isRequired,\n    height: PropTypes.number.isRequired,\n    margin: PropTypes.object.isRequired,\n    setCurrent: PropTypes.func.isRequired,\n    onMouseEnter: PropTypes.func,\n    onMouseMove: PropTypes.func,\n    onMouseLeave: PropTypes.func,\n    onClick: PropTypes.func,\n    tooltip: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,\n    debug: PropTypes.bool.isRequired,\n}\n\nexport default memo(Mesh)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { Fragment, useState } from 'react'\nimport {\n    bindDefs,\n    withContainer,\n    useDimensions,\n    useTheme,\n    SvgWrapper,\n    CartesianMarkers,\n} from '@nivo/core'\nimport { useInheritedColor } from '@nivo/colors'\nimport { Axes, Grid } from '@nivo/axes'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { Crosshair } from '@nivo/tooltip'\nimport { useLine } from './hooks'\nimport { LinePropTypes, LineDefaultProps } from './props'\nimport Areas from './Areas'\nimport Lines from './Lines'\nimport Slices from './Slices'\nimport Points from './Points'\nimport Mesh from './Mesh'\n\nconst Line = props => {\n    const {\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        layers,\n        curve,\n        areaBaselineValue,\n\n        colors,\n\n        margin: partialMargin,\n        width,\n        height,\n\n        axisTop,\n        axisRight,\n        axisBottom,\n        axisLeft,\n        enableGridX,\n        enableGridY,\n        gridXValues,\n        gridYValues,\n\n        lineWidth,\n        enableArea,\n        areaOpacity,\n        areaBlendMode,\n\n        enablePoints,\n        pointSymbol,\n        pointSize,\n        pointColor,\n        pointBorderWidth,\n        pointBorderColor,\n        enablePointLabel,\n        pointLabel,\n        pointLabelYOffset,\n\n        defs,\n        fill,\n\n        markers,\n\n        legends,\n\n        isInteractive,\n\n        useMesh,\n        debugMesh,\n\n        onMouseEnter,\n        onMouseMove,\n        onMouseLeave,\n        onClick,\n\n        tooltip,\n\n        enableSlices,\n        debugSlices,\n        sliceTooltip,\n\n        enableCrosshair,\n        crosshairType,\n\n        role,\n    } = props\n\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        legendData,\n        toggleSerie,\n        lineGenerator,\n        areaGenerator,\n        series,\n        xScale,\n        yScale,\n        slices,\n        points,\n    } = useLine({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n        enableSlices,\n    })\n\n    const theme = useTheme()\n    const getPointColor = useInheritedColor(pointColor, theme)\n    const getPointBorderColor = useInheritedColor(pointBorderColor, theme)\n\n    const [currentPoint, setCurrentPoint] = useState(null)\n    const [currentSlice, setCurrentSlice] = useState(null)\n\n    const layerById = {\n        grid: (\n            <Grid\n                key=\"grid\"\n                theme={theme}\n                width={innerWidth}\n                height={innerHeight}\n                xScale={enableGridX ? xScale : null}\n                yScale={enableGridY ? yScale : null}\n                xValues={gridXValues}\n                yValues={gridYValues}\n            />\n        ),\n        markers: (\n            <CartesianMarkers\n                key=\"markers\"\n                markers={markers}\n                width={innerWidth}\n                height={innerHeight}\n                xScale={xScale}\n                yScale={yScale}\n                theme={theme}\n            />\n        ),\n        axes: (\n            <Axes\n                key=\"axes\"\n                xScale={xScale}\n                yScale={yScale}\n                width={innerWidth}\n                height={innerHeight}\n                theme={theme}\n                top={axisTop}\n                right={axisRight}\n                bottom={axisBottom}\n                left={axisLeft}\n            />\n        ),\n        areas: null,\n        lines: (\n            <Lines key=\"lines\" lines={series} lineGenerator={lineGenerator} lineWidth={lineWidth} />\n        ),\n        slices: null,\n        points: null,\n        crosshair: null,\n        mesh: null,\n        legends: legends.map((legend, i) => (\n            <BoxLegendSvg\n                key={`legend.${i}`}\n                {...legend}\n                containerWidth={innerWidth}\n                containerHeight={innerHeight}\n                data={legend.data || legendData}\n                theme={theme}\n                toggleSerie={legend.toggleSerie ? toggleSerie : undefined}\n            />\n        )),\n    }\n\n    const boundDefs = bindDefs(defs, series, fill)\n\n    if (enableArea) {\n        layerById.areas = (\n            <Areas\n                key=\"areas\"\n                areaGenerator={areaGenerator}\n                areaOpacity={areaOpacity}\n                areaBlendMode={areaBlendMode}\n                lines={series}\n            />\n        )\n    }\n\n    if (isInteractive && enableSlices !== false) {\n        layerById.slices = (\n            <Slices\n                key=\"slices\"\n                slices={slices}\n                axis={enableSlices}\n                debug={debugSlices}\n                height={innerHeight}\n                tooltip={sliceTooltip}\n                current={currentSlice}\n                setCurrent={setCurrentSlice}\n            />\n        )\n    }\n\n    if (enablePoints) {\n        layerById.points = (\n            <Points\n                key=\"points\"\n                points={points}\n                symbol={pointSymbol}\n                size={pointSize}\n                color={getPointColor}\n                borderWidth={pointBorderWidth}\n                borderColor={getPointBorderColor}\n                enableLabel={enablePointLabel}\n                label={pointLabel}\n                labelYOffset={pointLabelYOffset}\n            />\n        )\n    }\n\n    if (isInteractive && enableCrosshair) {\n        if (currentPoint !== null) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentPoint.x}\n                    y={currentPoint.y}\n                    type={crosshairType}\n                />\n            )\n        }\n        if (currentSlice !== null) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentSlice.x}\n                    y={currentSlice.y}\n                    type={enableSlices}\n                />\n            )\n        }\n    }\n\n    if (isInteractive && useMesh && enableSlices === false) {\n        layerById.mesh = (\n            <Mesh\n                key=\"mesh\"\n                points={points}\n                width={innerWidth}\n                height={innerHeight}\n                margin={margin}\n                current={currentPoint}\n                setCurrent={setCurrentPoint}\n                onMouseEnter={onMouseEnter}\n                onMouseMove={onMouseMove}\n                onMouseLeave={onMouseLeave}\n                onClick={onClick}\n                tooltip={tooltip}\n                debug={debugMesh}\n            />\n        )\n    }\n\n    return (\n        <SvgWrapper\n            defs={boundDefs}\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            role={role}\n        >\n            {layers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return (\n                        <Fragment key={i}>\n                            {layer({\n                                ...props,\n                                innerWidth,\n                                innerHeight,\n                                series,\n                                slices,\n                                points,\n                                xScale,\n                                yScale,\n                                lineGenerator,\n                                areaGenerator,\n                                currentPoint,\n                                setCurrentPoint,\n                                currentSlice,\n                                setCurrentSlice,\n                            })}\n                        </Fragment>\n                    )\n                }\n\n                return layerById[layer]\n            })}\n        </SvgWrapper>\n    )\n}\n\nLine.propTypes = LinePropTypes\nLine.defaultProps = LineDefaultProps\n\nexport default withContainer(Line)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { ResponsiveWrapper } from '@nivo/core'\nimport Line from './Line'\n\nconst ResponsiveLine = props => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <Line width={width} height={height} {...props} />}\n    </ResponsiveWrapper>\n)\n\nexport default ResponsiveLine\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { createElement, useRef, useEffect, useState, useCallback, forwardRef } from 'react'\nimport {\n    withContainer,\n    useDimensions,\n    useTheme,\n    getRelativeCursor,\n    isCursorInRect,\n} from '@nivo/core'\nimport { renderAxesToCanvas, renderGridLinesToCanvas } from '@nivo/axes'\nimport { renderLegendToCanvas } from '@nivo/legends'\nimport { useTooltip } from '@nivo/tooltip'\nimport { useVoronoiMesh, renderVoronoiToCanvas, renderVoronoiCellToCanvas } from '@nivo/voronoi'\nimport { LineCanvasPropTypes, LineCanvasDefaultProps } from './props'\nimport { useLine } from './hooks'\n\nconst LineCanvas = ({\n    width,\n    height,\n    margin: partialMargin,\n    pixelRatio,\n\n    data,\n    xScale: xScaleSpec,\n    xFormat,\n    yScale: yScaleSpec,\n    yFormat,\n    curve,\n\n    layers,\n\n    colors,\n    lineWidth,\n\n    enableArea,\n    areaBaselineValue,\n    areaOpacity,\n\n    enablePoints,\n    pointSize,\n    pointColor,\n    pointBorderWidth,\n    pointBorderColor,\n\n    enableGridX,\n    gridXValues,\n    enableGridY,\n    gridYValues,\n    axisTop,\n    axisRight,\n    axisBottom,\n    axisLeft,\n\n    legends,\n\n    isInteractive,\n    debugMesh,\n    //onMouseEnter,\n    //onMouseMove,\n    onMouseLeave,\n    onClick,\n    tooltip,\n\n    canvasRef,\n}) => {\n    const canvasEl = useRef(null)\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n    const theme = useTheme()\n    const [currentPoint, setCurrentPoint] = useState(null)\n\n    const { lineGenerator, areaGenerator, series, xScale, yScale, points } = useLine({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n    })\n\n    const { delaunay, voronoi } = useVoronoiMesh({\n        points,\n        width: innerWidth,\n        height: innerHeight,\n        debug: debugMesh,\n    })\n\n    useEffect(() => {\n        if (canvasRef) {\n            canvasRef.current = canvasEl.current\n        }\n\n        canvasEl.current.width = outerWidth * pixelRatio\n        canvasEl.current.height = outerHeight * pixelRatio\n\n        const ctx = canvasEl.current.getContext('2d')\n\n        ctx.scale(pixelRatio, pixelRatio)\n\n        ctx.fillStyle = theme.background\n        ctx.fillRect(0, 0, outerWidth, outerHeight)\n        ctx.translate(margin.left, margin.top)\n\n        layers.forEach(layer => {\n            if (typeof layer === 'function') {\n                layer({\n                    ctx,\n                    innerWidth,\n                    innerHeight,\n                    series,\n                    points,\n                    xScale,\n                    yScale,\n                    lineWidth,\n                    lineGenerator,\n                    areaGenerator,\n                    currentPoint,\n                    setCurrentPoint,\n                })\n            }\n\n            if (layer === 'grid' && theme.grid.line.strokeWidth > 0) {\n                ctx.lineWidth = theme.grid.line.strokeWidth\n                ctx.strokeStyle = theme.grid.line.stroke\n\n                enableGridX &&\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: xScale,\n                        axis: 'x',\n                        values: gridXValues,\n                    })\n\n                enableGridY &&\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: yScale,\n                        axis: 'y',\n                        values: gridYValues,\n                    })\n            }\n\n            if (layer === 'axes') {\n                renderAxesToCanvas(ctx, {\n                    xScale,\n                    yScale,\n                    width: innerWidth,\n                    height: innerHeight,\n                    top: axisTop,\n                    right: axisRight,\n                    bottom: axisBottom,\n                    left: axisLeft,\n                    theme,\n                })\n            }\n\n            if (layer === 'areas' && enableArea === true) {\n                ctx.save()\n                ctx.globalAlpha = areaOpacity\n\n                areaGenerator.context(ctx)\n                series.forEach(serie => {\n                    ctx.fillStyle = serie.color\n                    ctx.beginPath()\n                    areaGenerator(serie.data.map(d => d.position))\n                    ctx.fill()\n                })\n\n                ctx.restore()\n            }\n\n            if (layer === 'lines') {\n                lineGenerator.context(ctx)\n                series.forEach(serie => {\n                    ctx.strokeStyle = serie.color\n                    ctx.lineWidth = lineWidth\n                    ctx.beginPath()\n                    lineGenerator(serie.data.map(d => d.position))\n                    ctx.stroke()\n                })\n            }\n\n            if (layer === 'points' && enablePoints === true && pointSize > 0) {\n                points.forEach(point => {\n                    ctx.fillStyle = point.color\n                    ctx.beginPath()\n                    ctx.arc(point.x, point.y, pointSize / 2, 0, 2 * Math.PI)\n                    ctx.fill()\n\n                    if (pointBorderWidth > 0) {\n                        ctx.strokeStyle = point.borderColor\n                        ctx.lineWidth = pointBorderWidth\n                        ctx.stroke()\n                    }\n                })\n            }\n\n            if (layer === 'mesh' && debugMesh === true) {\n                renderVoronoiToCanvas(ctx, voronoi)\n                if (currentPoint) {\n                    renderVoronoiCellToCanvas(ctx, voronoi, currentPoint.index)\n                }\n            }\n\n            if (layer === 'legends') {\n                const legendData = series\n                    .map(serie => ({\n                        id: serie.id,\n                        label: serie.id,\n                        color: serie.color,\n                    }))\n                    .reverse()\n\n                legends.forEach(legend => {\n                    renderLegendToCanvas(ctx, {\n                        ...legend,\n                        data: legend.data || legendData,\n                        containerWidth: innerWidth,\n                        containerHeight: innerHeight,\n                        theme,\n                    })\n                })\n            }\n        })\n    }, [\n        canvasEl,\n        outerWidth,\n        outerHeight,\n        layers,\n        theme,\n        lineGenerator,\n        series,\n        xScale,\n        yScale,\n        enableGridX,\n        gridXValues,\n        enableGridY,\n        gridYValues,\n        axisTop,\n        axisRight,\n        axisBottom,\n        axisLeft,\n        legends,\n        points,\n        enablePoints,\n        pointSize,\n        currentPoint,\n    ])\n\n    const getPointFromMouseEvent = useCallback(\n        event => {\n            const [x, y] = getRelativeCursor(canvasEl.current, event)\n            if (!isCursorInRect(margin.left, margin.top, innerWidth, innerHeight, x, y)) return null\n\n            const pointIndex = delaunay.find(x - margin.left, y - margin.top)\n            return points[pointIndex]\n        },\n        [canvasEl, margin, innerWidth, innerHeight, delaunay]\n    )\n\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseHover = useCallback(\n        event => {\n            const point = getPointFromMouseEvent(event)\n            setCurrentPoint(point)\n\n            if (point) {\n                showTooltipFromEvent(createElement(tooltip, { point }), event)\n            } else {\n                hideTooltip()\n            }\n        },\n        [getPointFromMouseEvent, setCurrentPoint, showTooltipFromEvent, hideTooltip, tooltip]\n    )\n\n    const handleMouseLeave = useCallback(\n        event => {\n            hideTooltip()\n            setCurrentPoint(null)\n            currentPoint && onMouseLeave && onMouseLeave(currentPoint, event)\n        },\n        [hideTooltip, setCurrentPoint, onMouseLeave]\n    )\n\n    const handleClick = useCallback(\n        event => {\n            if (onClick) {\n                const point = getPointFromMouseEvent(event)\n                point && onClick(point, event)\n            }\n        },\n        [getPointFromMouseEvent, onClick]\n    )\n\n    return (\n        <canvas\n            ref={canvasEl}\n            width={outerWidth * pixelRatio}\n            height={outerHeight * pixelRatio}\n            style={{\n                width: outerWidth,\n                height: outerHeight,\n                cursor: isInteractive ? 'auto' : 'normal',\n            }}\n            onMouseEnter={isInteractive ? handleMouseHover : undefined}\n            onMouseMove={isInteractive ? handleMouseHover : undefined}\n            onMouseLeave={isInteractive ? handleMouseLeave : undefined}\n            onClick={isInteractive ? handleClick : undefined}\n        />\n    )\n}\n\nLineCanvas.propTypes = LineCanvasPropTypes\nLineCanvas.defaultProps = LineCanvasDefaultProps\n\nconst LineCanvasWithContainer = withContainer(LineCanvas)\n\nexport default forwardRef((props, ref) => <LineCanvasWithContainer {...props} canvasRef={ref} />)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { forwardRef } from 'react'\nimport { ResponsiveWrapper } from '@nivo/core'\nimport LineCanvas from './LineCanvas'\n\nconst ResponsiveLineCanvas = (props, ref) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <LineCanvas width={width} height={height} {...props} ref={ref} />}\n    </ResponsiveWrapper>\n)\n\nexport default forwardRef(ResponsiveLineCanvas)\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}